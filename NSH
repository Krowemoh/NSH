*
* COMPILER DIRECTIVES
*
$DEFINE DATABASE.UV
$DEFINE PLATFORM.LINUX
*
*ASI********************************************************************
*                                                                      *
* Create Date  Req#  Who  Description                                  *
* 23 OCT 2021  N/A   NT   NovaShell v0.1                               *
* 07 NOV 2021  N/A   NT   NovaShell v0.2                               *
* 24 MAR 2022  N/A   NT   NovaShell v0.3                               *
* 31 MAY 2022  N/A   NT   NovaShell v0.4                               *
* 20 JUN 2022  N/A   NT   NovaShell v0.5                               *
*                                                                      *
************************************************************************
* Special Instructions                                                 *
*                                                                      *
************************************************************************
* Change History                                                       *
*                                                                      *
* Change Date  Req#  Who  Description                                  *
* 07 NOV 2021  N/A   NT   Added Dynamic Terminal Escape Codes          *
* 24 MAR 2022  N/A   NT   Add History Search with Arrow Keys           *
*                         Enhance Autocomplete to Complete Substring   *
*                         Don't Assume Files are Opened Successfully   *
*                         Account Specific History Files               *
*                         Auto Create NSH-HISTORY-FILE in Accounts     *
*                         Clean Up SEARCH                              *
*                         Allow multiple .X Command Numbers            *
* 31 MAY 2022  N/A   NT   Move NSH-HISTORY-FILE to /tmp/               *
*                         Remove Account Specific History              *
* 10 JUN 2022  N/A   NT   Add Support for D3 and Windows               *
* 20 JUN 2022  N/A   NT   Add a date and time conversion utility       *
* 20 JUN 2022  N/A   NT   D3 - Breaking Change - Search = FIND         *
*                         You cannot use the native search in D3       *
*                                                                      *
************************************************************************
*
* VERSION
*
    MAJOR.VERSION = '0'
    MINOR.VERSION = '5'
    PATCH.VERSION = '4'
*
    VERSION = MAJOR.VERSION : '.' : MINOR.VERSION : '.' : PATCH.VERSION
*
* NSH MASTER URL
* 
    NSH.URL = 'https://raw.githubusercontent.com/Krowemoh/NovaShell/main/NSH'
*
* CONSTANTS
*
      @USER1 = 'NSH'
      @USER2 = 'NSH'
*
      BOTTOM = @(0,66)
*
      EQU TRUE TO 1
      EQU FALSE TO 0
*
      STARTUP.MATRIX = ''
      STARTUP.MATRIX<-1> = 'PQ'
      STARTUP.MATRIX<-1> = 'HNSH'
*

*
* SYSTEM FILE FOR UV ACCOUNTS
*
      $IFDEF DATABASE.UV
        LOGTO.FILENAME = 'UV.ACCOUNT'
      $ENDIF 
      $IFDEF DATABASE.D3
        LOGTO.FILENAME = 'SYSTEM'
      $ENDIF
*
      LOGTO.OPENED = TRUE
      OPEN '',LOGTO.FILENAME TO LOGTO.FILE ELSE
         PRINT 'NSH: Unable to open file: ' : LOGTO.FILENAME  : ' - Press RETURN'
         LOGTO.OPENED = FALSE
      END
*
* SYSTEM FILE FOR VERBS
*
      NEW.ACC.OPENED = TRUE
      OPEN '','NEWACC' TO NEWACC.FILE ELSE
         PRINT 'NSH: Unable to open file: NEWACC - Press RETURN'
         NEW.ACC.OPENED = FALSE
      END
*
* SYSTEM FILE FOR HELP PAGES
*
      SYS.HELP.OPENED = TRUE
      OPEN '','SYS.HELP' TO SYS.HELP.FILE ELSE
         PRINT 'NSH: Unable to open file: SYS.HELP - Press RETURN'
         SYS.HELP.OPENED = FALSE
      END
*
* SYSTEM FILE FOR BASIC PAGES
*
      BASIC.HELP.OPENED = TRUE
      OPEN '','BASIC.HELP' TO BASIC.HELP.FILE ELSE
         PRINT 'NSH: Unable to open file: BASIC.HELP - Press RETURN'
         BASIC.HELP.OPENED = FALSE
      END
*
* SET VOC
*
     $IFDEF DATABASE.UV
        VOC = 'VOC'
     $ENDIF
     $IFDEF DATABASE.D3
        VOC = 'MD'
     $ENDIF
*
* FILE FOR SAVING COMMAND HISTORY
*
      NSH.HISTORY.OPENED = TRUE
      OPEN '','NSH-HISTORY-FILE' TO NSH.HISTORY.FILE ELSE
         OPEN '',VOC TO VOC.FILE THEN
            NSH.ENTRY = ''
            $IFDEF PLATFORM.LINUX
                $IFDEF DATABASE.UV
                    NSH.ENTRY<1> = 'F'
                    NSH.ENTRY<2> = '/tmp/.nsh/'
                    NSH.ENTRY<3> = '/tmp/.nsh/'
                $ENDIF
                $IFDEF DATABASE.D3
                    NSH.ENTRY<1> = 'Q'
                    NSH.ENTRY<3> = 'UNIX:/tmp/.nsh/'
                $ENDIF
            $ENDIF
            $IFDEF PLATFORM.WINDOWS
                $IFDEF DATABASE.UV
                    NSH.ENTRY<1> = 'F'
                    NSH.ENTRY<2> = 'DOS:C:\.nsh\'
                    NSH.ENTRY<3> = 'DOS:C:\.nsh\'
                $ENDIF
                $IFDEF DATABASE.D3
                    NSH.ENTRY<1> = 'Q'
                    NSH.ENTRY<3> = 'DOS:C:\.nsh\'
                $ENDIF
            $ENDIF
*
            WRITE NSH.ENTRY ON VOC.FILE,'NSH-HISTORY-FILE'
*
            OPEN '','NSH-HISTORY-FILE' TO NSH.HISTORY.FILE ELSE
                $IFDEF PLATFORM.LINUX
                    $IFDEF DATABASE.UV
                        EXECUTE 'SH -c "mkdir /tmp/.nsh/"'
                    $ENDIF
                    $IFDEF DATABASE.UV
                        EXECUTE '!mkdir /tmp/.nsh/'
                    $ENDIF
                $ENDIF
                $IFDEF PLATFORM.WINDOWS
                    EXECUTE '! mkdir C:\.nsh'
                $ENDIF
                OPEN '','NSH-HISTORY-FILE' TO NSH.HISTORY.FILE ELSE
                    NSH.HISTORY.OPENED = FALSE
                END
            END
         END ELSE
            PRINT 'NSH: Unable to open file: VOC - Press RETURN'
            NSH.HISTORY.OPENED = FALSE
         END
      END
*
    PROMPT ''
*
* CLEARING LINES
*
      CLEAR.REST.OF.SCREEN = @(-3)
      CLEAR.REST.OF.LINE = @(-4)
      CLEAR.LINE = @(0) : CLEAR.REST.OF.LINE
*
      EQU HISTORY TO 1
      EQU TRUE.HISTORY TO 2
*
      EQU KEY.CTRL.A TO CHAR(1)
      EQU KEY.ESCAPE TO CHAR(27)
      EQU KEY.BACKSPACE TO CHAR(8)
      EQU KEY.TAB TO CHAR(9)
      EQU KEY.LINE.FEED TO CHAR(10)
      EQU KEY.CARRIAGE.RETURN TO CHAR(13)
      EQU KEY.EXCLAIMATION.MARK TO CHAR(33)
      EQU KEY.DELETE TO CHAR(127)
*
* MAKE TERMINAL MAX SIZE BASED ON WINTEGRATE
*
      EXECUTE 'TERM 132,66'
*
* TERMINAL INITIALIZATION
*
      EQU TERMINAL.TYPE.ATTRIBUTE TO 1
      EQU TERMINAL.UP.ATTRIBUTE TO 2
      EQU TERMINAL.DOWN.ATTRIBUTE TO 3
      EQU TERMINAL.LEFT.ATTRIBUTE TO 4
      EQU TERMINAL.RIGHT.ATTRIBUTE TO 5
*
      $IFDEF DATABASE.UV
        TERMINAL.CODES = TERMINFO(0)
        TERMINAL.TYPE = FIELD(TERMINAL.CODES<1>,'|',1)
      $ENDIF
      $IFDEF DATABASE.D3
        TERMINAL.CODES = OCONV("", "u0004")
        TERMINAL.TYPE = TERMINAL.CODES<1>
      $ENDIF
*
      $IFDEF PLATFORM.LINUX
        IF TERMINAL.TYPE = 'vp' THEN
            PRINT 'NSH: Re-mapped susp to ^B (Ctrl B)'
            $IFDEF DATABASE.UV
                EXECUTE 'SH -c "stty susp ^B"'
            $ENDIF
            $IFDEF DATABASE.D3
                EXECUTE '!stty susp ^B'
            $ENDIF
            TERMINAL.TYPE = 'viewpoint'
        END
      $ENDIF
*
      TERMINAL = ''
      TERMINAL<TERMINAL.TYPE.ATTRIBUTE,1> = TERMINAL.TYPE
*
      $IFDEF PLATFORM.LINUX
        $IFDEF DATABASE.UV
            EXECUTE 'SH -c "infocmp "' : TERMINAL.TYPE CAPTURING RESULTS
        $ENDIF
        $IFDEF DATABASE.D3
            EXECUTE '!infocmp ' : TERMINAL.TYPE CAPTURING RESULTS
        $ENDIF
*
        ARROW.CODES = ''
        ARROW.CODES<1,-1> = 'kcuu1='
        ARROW.CODES<1,-1> = 'kcud1='
        ARROW.CODES<1,-1> = 'kcub1='
        ARROW.CODES<1,-1> = 'kcuf1='
*
        ARROW.CTR = 0
        LOOP
            ARROW.CTR = ARROW.CTR + 1
            ARROW.CODE = ARROW.CODES<1,ARROW.CTR>
        UNTIL ARROW.CODE = '' DO
            STR = ''
            START.POS = INDEX(RESULTS, ARROW.CODE, 1)
            IF START.POS # 0 THEN
                STR = RESULTS[START.POS,999999]
                START.POS = LEN(ARROW.CODE) + 1
                END.POS = INDEX(STR, ',', 1) - START.POS
                STR = STR[START.POS,END.POS]
                IF INDEX(STR,'^',1) # 0 THEN
                    STR = STR[2,99999]
                END ELSE IF INDEX(STR,'\E',1) THEN
                    STR = STR[3,99999]
                END ELSE
                    STR = ''
                END
            END
            TERMINAL<-1> = STR
        REPEAT
      $ENDIF
*
      TERMINAL.POS = 1
*
* SHELL INITIALIZATION
*
      $IFDEF DATABASE.UV
        USER.NAME = @ACCOUNT
        PORT.NUMBER = @USERNO
        ACCOUNT.NAME = @WHO
      $ENDIF
*
      $IFDEF DATABASE.D3
        USER.NAME = @USER
        PORT.NUMBER = @USERNO
        ACCOUNT.NAME = @ACCOUNT
      $ENDIF
*
      COMMAND.HISTORY.FILE.NAME = USER.NAME : '.nsh_history'
*
      IF NSH.HISTORY.OPENED THEN
         READ COMMAND.STACK FROM NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME ELSE COMMAND.STACK = ''
      END ELSE
         COMMAND.STACK = ''
      END
*
      SEARCH.COMMAND = ''
      USER.INPUT = TRUE
      TRUE.HISTORY.STACK.POINTER = 0
*
      SERIES.VERBS = ''
      SERIES.VERBS<1,-1> = 'SELECT'
      SERIES.VERBS<1,-1> = 'SSELECT'
      SERIES.VERBS<1,-1> = 'GET-LIST'
      SERIES.VERBS<1,-1> = 'GET.LIST'
      SERIES.VERBS<1,-1> = 'SEARCH'
*
      SERIES = ''
*
      COMMAND = ''
      CURSOR.POSITION = -1
*
      TAB.PRESSED = FALSE
*
      PRINT.SHELL.PROMPT = TRUE
*
      LINUX.COMMAND.MODE = FALSE
*
      PRINT 'Welcome to NovaShell ' : VERSION : '!'
      PRINT 'NSH: Your term is set to ' : TERMINAL.TYPE : '.'
*
* PRIMARY EXECUTATION LOOP
*
      LOOP WHILE TRUE DO
         IF PRINT.SHELL.PROMPT THEN
            SHELL.PREFIX = USER.NAME : ':' : PORT.NUMBER : '@' : ACCOUNT.NAME
            SHELL.DEFAULT.PROMPT = SHELL.PREFIX : '> '
            SERIES.PROMPT = SHELL.PREFIX : '>> '
*
            IF SERIES = '' THEN
               SHELL.PROMPT = SHELL.DEFAULT.PROMPT
            END ELSE
               SHELL.PROMPT = SERIES.PROMPT
            END
*
            PRINT BOTTOM :
            PRINT SHELL.PROMPT :
*
            CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
         END
*
         ESCAPE.SEQUENCE = ''
*
* SECONDARY INPUT LOOP
*
         LOOP WHILE TRUE DO
            AT.BEGINNING = FALSE
*
* CHARACTER ENTRY
*
            $IFDEF DATABASE.UV
                CHR = KEYIN()
            $ENDIF
            $IFDEF DATABASE.D3
                INPUT CHR, 0
            $ENDIF
*
* PROCESS CHARACTER
*
            ASCII.CODE = SEQ(CHR)
*
            BEGIN CASE
               CASE ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN)
                  LINUX.COMMAND.MODE = FALSE
                  CURSOR.POSITION = LEN(SHELL.PROMPT)
                  TRUE.HISTORY.STACK.POINTER = 0 ; 
                  SEARCH.COMMAND = ''
                  USER.INPUT = TRUE
                  EXIT
*
               CASE ASCII.CODE = SEQ(KEY.TAB)
                  TAB.PRESSED = TRUE
                  EXIT
*
               CASE ASCII.CODE = SEQ(KEY.EXCLAIMATION.MARK)
                  LINUX.COMMAND.MODE = TRUE
                  $IFDEF DATABASE.UV
                    PRINT CHR :
                  $ENDIF
                  COMMAND = COMMAND : CHR
                  CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  CONTINUE
*
               CASE ASCII.CODE = SEQ(KEY.CTRL.A)
                  PRINT BOTTOM :
                  PRINT SHELL.PROMPT :
                  PRINT CLEAR.REST.OF.SCREEN :
                  PRINT.SHELL.PROMPT = FALSE
                  TRUE.HISTORY.STACK.POINTER = 0 ; 
                  COMMAND = ''
                  CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  CONTINUE
*
               CASE ASCII.CODE = SEQ(KEY.BACKSPACE) OR ASCII.CODE = SEQ(KEY.DELETE)
                  COMMAND.LENGTH = LEN(COMMAND)
*
                  TRUE.HISTORY.STACK.POINTER = 0 ; 
                  SEARCH.COMMAND = ''
                  USER.INPUT = TRUE
*
                  IF COMMAND.LENGTH = 0 THEN
                     AT.BEGINNING = TRUE

                  END ELSE IF COMMAND.LENGTH > 0 THEN
*
                     CURSOR.IN.COMMAND = CURSOR.POSITION - LEN(SHELL.PROMPT)
*
                     IF CURSOR.IN.COMMAND <= 0 THEN
                        CONTINUE
                     END
*
                     PRINT CHR :
*
                     CURSOR.POSITION = CURSOR.POSITION - 1
*
                     IF CURSOR.IN.COMMAND = LEN(COMMAND) THEN
                        COMMAND = COMMAND[1,LEN(COMMAND) - 1]
                        PRINT CLEAR.REST.OF.LINE :
                     END ELSE
*
* SPECIAL DELETE FOR VIEWPOINT
*
                        IF TERMINAL<TERMINAL.TYPE.ATTRIBUTE, TERMINAL.POS> = 'viewpoint' THEN
                           COMMAND = COMMAND[1,CURSOR.IN.COMMAND-1] : COMMAND[CURSOR.IN.COMMAND+1,9999]
                           PRINT BOTTOM :
                           PRINT SHELL.PROMPT :
                           PRINT COMMAND : CLEAR.REST.OF.SCREEN :
                           $IFDEF DATABASE.UV
                                PRINT @(-70, CURSOR.POSITION) :
                           $ENDIF
                           $IFDEF DATABASE.D3
                                FOR X = 1 TO LEN(COMMAND) - CURSOR.IN.COMMAND + 1
                                    PRINT @(-9) :
                                NEXT X
                           $ENDIF
*
                        END ELSE
                           COMMAND = COMMAND[1,CURSOR.IN.COMMAND-1] : COMMAND[CURSOR.IN.COMMAND+1,9999]
                           $IFDEF DATABASE.UV
                                PRINT @(-22) :
                           $ENDIF
                        END
                     END
                  END
*
                  CONTINUE
*
               CASE ASCII.CODE > 0 AND ASCII.CODE < 27
                  ESCAPE.SEQUENCE = ASCII.CODE
                  EXIT
*
               CASE ASCII.CODE = SEQ(KEY.ESCAPE)
                  $IFDEF DATABASE.UV
                      CHR = KEYIN()
                  $ENDIF
                  $IFDEF DATABASE.D3
                      INPUT CHR, 0
                  $ENDIF
                  ESCAPE.SEQUENCE = CHR
*
                  IF CHR = 'O' THEN
                    $IFDEF DATABASE.UV
                        CHR = KEYIN()
                    $ENDIF
                    $IFDEF DATABASE.D3
                        INPUT CHR, 0
                    $ENDIF
                     ESCAPE.SEQUENCE = ESCAPE.SEQUENCE : CHR
                  END ELSE IF CHR = '[' THEN
                     LOOP
                        $IFDEF DATABASE.UV
                            CHR = KEYIN()
                        $ENDIF
                        $IFDEF DATABASE.D3
                            INPUT CHR, 0
                        $ENDIF
                        ESCAPE.SEQUENCE = ESCAPE.SEQUENCE : CHR
                     UNTIL NOT(NUM(CHR)) DO REPEAT
                  END
*
                  EXIT
*
               CASE ASCII.CODE >= SEQ('a') AND ASCII.CODE <= SEQ('z')
                  IF NOT(LINUX.COMMAND.MODE) THEN
                     CHR = OCONV(CHR,'MCU')
                  END
                  $IFDEF DATABASE.UV
                    PRINT CHR :
                  $ENDIF
*
               CASE ASCII.CODE >= SEQ('A') AND ASCII.CODE <= SEQ('Z')
                  IF NOT(LINUX.COMMAND.MODE) THEN
                     CHR = OCONV(CHR,'MCL')
                  END
                  $IFDEF DATABASE.UV
                    PRINT CHR :
                  $ENDIF
*
               CASE TRUE
                  $IFDEF DATABASE.UV
                    PRINT CHR :
                  $ENDIF
            END CASE
*
            IF NOT(AT.BEGINNING) THEN
               CURSOR.POSITION.IN.COMMAND = CURSOR.POSITION - LEN(SHELL.PROMPT)
               IF CURSOR.POSITION.IN.COMMAND = LEN(COMMAND) THEN
                  COMMAND = COMMAND : CHR
               END ELSE
                  COMMAND = COMMAND[1,CURSOR.POSITION.IN.COMMAND] : CHR : COMMAND[CURSOR.POSITION.IN.COMMAND+1,9999]
               END
               CURSOR.POSITION = CURSOR.POSITION + 1
            END
*
         REPEAT
*
         PRINT.SHELL.PROMPT = TRUE
*
         COMMAND.STACK.LENGTH = DCOUNT(COMMAND.STACK<HISTORY>, @VM)
         TRUE.HISTORY.LENGTH = DCOUNT(COMMAND.STACK<TRUE.HISTORY>, @VM)
*
* ARROW KEY MANIPULATION
*
         IF ESCAPE.SEQUENCE # '' THEN
            BEGIN CASE
               CASE ESCAPE.SEQUENCE = TERMINAL<TERMINAL.UP.ATTRIBUTE, TERMINAL.POS> OR ESCAPE.SEQUENCE = 26 OR ESCAPE.SEQUENCE = 'OA' OR (TERMINAL.TYPE = 'wy50' AND ESCAPE.SEQUENCE = 11)
                  IF TRUE.HISTORY.STACK.POINTER < TRUE.HISTORY.LENGTH THEN
                     TRUE.HISTORY.STACK.POINTER = TRUE.HISTORY.STACK.POINTER + 1
                     IF COMMAND # '' AND USER.INPUT = TRUE THEN
                        SEARCH.COMMAND = COMMAND
                     END
                     IF SEARCH.COMMAND # '' THEN
                        PREVIOUS.COMMAND = COMMAND
                        LOOP
                           COMMAND = COMMAND.STACK<TRUE.HISTORY, TRUE.HISTORY.STACK.POINTER>
                        UNTIL (TRUE.HISTORY.STACK.POINTER >= TRUE.HISTORY.LENGTH OR INDEX(COMMAND,SEARCH.COMMAND,1) # 0) AND PREVIOUS.COMMAND # COMMAND DO
                           TRUE.HISTORY.STACK.POINTER = TRUE.HISTORY.STACK.POINTER + 1
                        REPEAT
                     END
                  END
*
                  COMMAND = COMMAND.STACK<TRUE.HISTORY, TRUE.HISTORY.STACK.POINTER>
                  USER.INPUT = FALSE
*
                  CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
                  PRINT BOTTOM :
                  PRINT SHELL.PROMPT :
                  PRINT COMMAND : CLEAR.REST.OF.SCREEN :
*
                  PRINT.SHELL.PROMPT = FALSE
*
                  CONTINUE
*
               CASE ESCAPE.SEQUENCE = TERMINAL<TERMINAL.DOWN.ATTRIBUTE, TERMINAL.POS> OR ESCAPE.SEQUENCE = 10 OR ESCAPE.SEQUENCE = 'OB' OR (TERMINAL.TYPE = 'wy50' AND ESCAPE.SEQUENCE = 10)
                  IF TRUE.HISTORY.STACK.POINTER > 1 THEN
                     TRUE.HISTORY.STACK.POINTER = TRUE.HISTORY.STACK.POINTER - 1
                     IF COMMAND # '' AND USER.INPUT = TRUE THEN
                        SEARCH.COMMAND = COMMAND
                     END
                     IF SEARCH.COMMAND # '' THEN
                        PREVIOUS.COMMAND = COMMAND
                        LOOP
                           COMMAND = COMMAND.STACK<TRUE.HISTORY, TRUE.HISTORY.STACK.POINTER>
                        UNTIL (TRUE.HISTORY.STACK.POINTER <= 0 OR INDEX(COMMAND,SEARCH.COMMAND,1) # 0) AND PREVIOUS.COMMAND # COMMAND DO
                           TRUE.HISTORY.STACK.POINTER = TRUE.HISTORY.STACK.POINTER - 1
                        REPEAT
                     END
                  END
*
                  IF TRUE.HISTORY.STACK.POINTER <= 0 THEN
                     TRUE.HISTORY.STACK.POINTER = 1
                  END
*
                  COMMAND = COMMAND.STACK<TRUE.HISTORY, TRUE.HISTORY.STACK.POINTER>
                  USER.INPUT = FALSE
                  CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
                  PRINT BOTTOM :
                  PRINT SHELL.PROMPT :
                  PRINT COMMAND : CLEAR.REST.OF.SCREEN :
*
                  PRINT.SHELL.PROMPT = FALSE
*
                  CONTINUE
*
               CASE ESCAPE.SEQUENCE = TERMINAL<TERMINAL.LEFT.ATTRIBUTE, TERMINAL.POS> OR ESCAPE.SEQUENCE = 21 OR ESCAPE.SEQUENCE = 'OD'
                  IF CURSOR.POSITION > LEN(SHELL.PROMPT) THEN
                     CURSOR.POSITION = CURSOR.POSITION - 1
                     PRINT @(CURSOR.POSITION, 66) :
                     $IFDEF DATABASE.UV
                        PRINT @(-20) :
                     $ENDIF
                  END
*
                  PRINT.SHELL.PROMPT = FALSE
                  CONTINUE
*
               CASE ESCAPE.SEQUENCE = TERMINAL<TERMINAL.RIGHT.ATTRIBUTE, TERMINAL.POS> OR ESCAPE.SEQUENCE = 6 OR ESCAPE.SEQUENCE = 'OC' OR (TERMINAL.TYPE = 'wy50' AND ESCAPE.SEQUENCE = 12)
                  IF CURSOR.POSITION < (LEN(SHELL.PROMPT) + LEN(COMMAND)) THEN
                     CURSOR.POSITION = CURSOR.POSITION + 1
                     PRINT @(CURSOR.POSITION, 66) :
                     $IFDEF DATABASE.UV
                        PRINT @(-20) :
                     $ENDIF
                  END
*
                  PRINT.SHELL.PROMPT = FALSE
                  CONTINUE
*
               CASE TERMINAL.TYPE = 'wy50' AND (ESCAPE.SEQUENCE = 'i' OR ESCAPE.SEQUENCE = 'I')
                   TAB.PRESSED = TRUE
*
               CASE TRUE
                  PRINT
                  PRINT 'NSH: Escape Sequence: ' : ESCAPE.SEQUENCE : ' not implemented.' :
            END CASE
         END
*
* TAB MANIPULATION
*
         IF TAB.PRESSED THEN
            TAB.PRESSED = FALSE
            NUMBER.OF.ARGUMENTS = DCOUNT(TRIM(COMMAND), ' ')
*
            VERB = FIELD(COMMAND,' ',1)
*
            BEGIN CASE
               CASE LOGTO.OPENED AND VERB = 'LOGTO'
                  VERB = TRIM(FIELD(COMMAND, ' ', 1))
                  WORD = FIELD(COMMAND, ' ', 2)
                  LENGTH.UP.TO.WORD = COL1()
                  CURRENT.COMMAND = COMMAND[1, LENGTH.UP.TO.WORD]
*
                  $IFDEF DATABASE.UV
                    STATEMENT = 'SSELECT ' : LOGTO.FILENAME  : ' = "': WORD : ']"'
                  $ENDIF
                  $IFDEF DATABASE.D3
                    STATEMENT = 'SSELECT ' : LOGTO.FILENAME  : ' = "': WORD : ']" WITH A2 = "FSI]"'
                  $ENDIF
*
                  EXECUTE STATEMENT CAPTURING RESULTS
*
                  RECORDS.SELECTED = FIELD(RESULTS<2>, ' ', 1)
*
                  IF RECORDS.SELECTED = 1 THEN
                     READNEXT ITEM.ID ELSE ITEM.ID = ''
*
                     PRINT
                     PRINT ITEM.ID
                     PRINT BOTTOM :
                     PRINT SHELL.PROMPT :
                     PRINT VERB : ' ' : ITEM.ID : CLEAR.REST.OF.SCREEN :
*
                     COMMAND = VERB : ' ' : ITEM.ID
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
*
                  END ELSE IF RECORDS.SELECTED = 0 THEN
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
*
                  END ELSE
                     PRINT
                     FIRST.WORD = ''
                     LAST.WORD = ''
                     LOOP
                        READNEXT ITEM.ID ELSE ITEM.ID = ''
                     UNTIL ITEM.ID = '' DO
                        PRINT ITEM.ID
                        IF FIRST.WORD = '' THEN FIRST.WORD = ITEM.ID
                        LAST.WORD = ITEM.ID
                     REPEAT
*
                     COMPLETED.WORD = ''
                     FOR I = 1 TO LEN(FIRST.WORD)
                        IF FIRST.WORD[I,1] = LAST.WORD[I,1] THEN
                           COMPLETED.WORD = COMPLETED.WORD : FIRST.WORD[I,1]
                        END ELSE EXIT
                     NEXT I
*
                     COMMAND = CURRENT.COMMAND : COMPLETED.WORD
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
                     PRINT BOTTOM :
                     PRINT SHELL.PROMPT :
                     PRINT COMMAND : CLEAR.REST.OF.SCREEN :
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
                  END
*
               CASE NEW.ACC.OPENED AND NUMBER.OF.ARGUMENTS = 1
                  STATEMENT = 'SSELECT NEWACC = "': TRIM(COMMAND) : ']"'
                  EXECUTE STATEMENT CAPTURING RESULTS
*
                  RECORDS.SELECTED = FIELD(RESULTS<2>, ' ', 1)
*
                  IF RECORDS.SELECTED = 1 THEN
                     READNEXT ITEM.ID ELSE ITEM.ID = ''
                     READV ITEM.DESCRIPTION FROM NEWACC.FILE, ITEM.ID, 1 ELSE ITEM.DESCRIPTION = ''
*
                     PRINT
                     PRINT ITEM.ID 'L#25' : ITEM.DESCRIPTION
                     PRINT BOTTOM :
                     PRINT SHELL.PROMPT :
                     PRINT ITEM.ID : CLEAR.REST.OF.SCREEN :
*
                     COMMAND = ITEM.ID
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
*
                  END ELSE IF RECORDS.SELECTED = 0 THEN
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
*
                  END ELSE
                     PRINT
                     FIRST.WORD = ''
                     LAST.WORD = ''
                     LOOP
                        READNEXT ITEM.ID ELSE ITEM.ID = ''
                     UNTIL ITEM.ID = '' DO
                        READV ITEM.DESCRIPTION FROM NEWACC.FILE, ITEM.ID, 1 ELSE ITEM.DESCRIPTION = ''
                        PRINT ITEM.ID 'L#25' : ITEM.DESCRIPTION
                        IF FIRST.WORD = '' THEN FIRST.WORD = ITEM.ID
                        LAST.WORD = ITEM.ID
                     REPEAT
*
                     COMPLETED.WORD = ''
                     FOR I = 1 TO LEN(FIRST.WORD)
                        IF FIRST.WORD[I,1] = LAST.WORD[I,1] THEN
                           COMPLETED.WORD = COMPLETED.WORD : FIRST.WORD[I,1]
                        END ELSE EXIT
                     NEXT I
*
                     COMMAND = COMPLETED.WORD
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
                     PRINT BOTTOM :
                     PRINT SHELL.PROMPT :
                     PRINT COMMAND : CLEAR.REST.OF.SCREEN :
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
                  END
*
               CASE VERB # 'MAN' AND NUMBER.OF.ARGUMENTS = 2
                  VERB = TRIM(FIELD(COMMAND, ' ', 1))
                  WORD = FIELD(COMMAND, ' ', 2)
                  LENGTH.UP.TO.WORD = COL1()
                  CURRENT.COMMAND = COMMAND[1, LENGTH.UP.TO.WORD]
*
                  $IFDEF DATABASE.UV
                    STATEMENT = 'SSELECT MD = "': WORD : ']" WITH F1 = "F]""Q]"'
                  $ENDIF
                  $IFDEF DATABASE.D3
                    STATEMENT = 'SSELECT MD = "': WORD : ']" WITH A1 = "D]""Q]"'
                  $ENDIF
*
                  EXECUTE STATEMENT CAPTURING RESULTS
*
                  RECORDS.SELECTED = FIELD(RESULTS<2>, ' ', 1)
*
                  IF RECORDS.SELECTED = 1 THEN
                     READNEXT ITEM.ID ELSE ITEM.ID = ''
*
                     PRINT
                     PRINT ITEM.ID
                     PRINT BOTTOM :
                     PRINT SHELL.PROMPT :
                     PRINT VERB : ' ' : ITEM.ID : CLEAR.REST.OF.SCREEN :
*
                     COMMAND = VERB : ' ' : ITEM.ID
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
*
                  END ELSE IF RECORDS.SELECTED = 0 THEN
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
*
                  END ELSE
                     PRINT
                     FIRST.WORD = ''
                     LAST.WORD = ''
                     LOOP
                        READNEXT ITEM.ID ELSE ITEM.ID = ''
                     UNTIL ITEM.ID = '' DO
                        PRINT ITEM.ID
                        IF FIRST.WORD = '' THEN FIRST.WORD = ITEM.ID
                        LAST.WORD = ITEM.ID
                     REPEAT
*
                     COMPLETED.WORD = ''
                     FOR I = 1 TO LEN(FIRST.WORD)
                        IF FIRST.WORD[I,1] = LAST.WORD[I,1] THEN
                           COMPLETED.WORD = COMPLETED.WORD : FIRST.WORD[I,1]
                        END ELSE EXIT
                     NEXT I
*
                     COMMAND = CURRENT.COMMAND : COMPLETED.WORD
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
                     PRINT BOTTOM :
                     PRINT SHELL.PROMPT :
                     PRINT COMMAND : CLEAR.REST.OF.SCREEN :
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
                  END
*
               CASE VERB = 'MAN' OR NUMBER.OF.ARGUMENTS > 2
                  VERB = TRIM(FIELD(COMMAND, ' ', 1))
*
                  IF VERB = 'MAN' THEN
                     HELP.FILE.NAME = TRIM(FIELD(COMMAND, ' ', 2))
                     IF HELP.FILE.NAME = "BASIC" THEN
                        FILE.LOOKUP = 'BASIC.HELP'
                     END ELSE
                        FILE.LOOKUP = 'SYS.HELP'
                     END
                  END ELSE
                     FILE.LOOKUP = TRIM(FIELD(COMMAND, ' ', 2))
                  END
*
                  LAST.ELEMENT = DCOUNT(COMMAND,' ')
                  WORD = FIELD(COMMAND, ' ', LAST.ELEMENT)
                  LENGTH.UP.TO.WORD = COL1()
                  CURRENT.COMMAND = COMMAND[1, LENGTH.UP.TO.WORD]
*
                  IF FILE.LOOKUP = 'BASIC.HELP' AND NOT(BASIC.HELP.OPENED) THEN
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
                  END
*
                  IF FILE.LOOKUP = 'SYS.HELP' AND NOT(SYS.HELP.OPENED) THEN
                     PRINT.SHELL.PROMPT = FALSE
                     CONTINUE
                  END
*
                  STATEMENT = 'SSELECT ' : FILE.LOOKUP : ' = "': WORD : ']"'
                  EXECUTE STATEMENT CAPTURING RESULTS
*
                  RECORDS.SELECTED = FIELD(RESULTS<2>, ' ', 1)
*
* DICTIONARY LOOK UP IF WE FOUND NOTHING IN FILE
*
                  BEGIN CASE
                     CASE RECORDS.SELECTED = 0
                        STATEMENT = 'SSELECT DICT ' : FILE.LOOKUP : ' = "': WORD : ']"'
                        EXECUTE STATEMENT CAPTURING RESULTS
*
                        RECORDS.SELECTED = FIELD(RESULTS<2>, ' ', 1)
*
                        IF RECORDS.SELECTED = 1 THEN
                           READNEXT ITEM.ID ELSE ITEM.ID = ''
*
                           PRINT
                           PRINT 'DICT: ' : ITEM.ID
                           PRINT BOTTOM :
                           PRINT SHELL.PROMPT :
                           PRINT CURRENT.COMMAND : ITEM.ID : CLEAR.REST.OF.SCREEN :
*
                           COMMAND = CURRENT.COMMAND : ITEM.ID
                           CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                           PRINT.SHELL.PROMPT = FALSE
                           CONTINUE
*
                        END ELSE IF RECORDS.SELECTED = 0 THEN
                           CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                           PRINT.SHELL.PROMPT = FALSE
                           CONTINUE
*
                        END ELSE
                           PRINT
*
                           FIRST.WORD = ''
                           LAST.WORD = ''
                           LOOP
                              READNEXT ITEM.ID ELSE ITEM.ID = ''
                           UNTIL ITEM.ID = '' DO
                              PRINT 'DICT: ' : ITEM.ID
                              IF FIRST.WORD = '' THEN FIRST.WORD = ITEM.ID
                              LAST.WORD = ITEM.ID
                           REPEAT
*
                           COMPLETED.WORD = ''
                           FOR I = 1 TO LEN(FIRST.WORD)
                              IF FIRST.WORD[I,1] = LAST.WORD[I,1] THEN
                                 COMPLETED.WORD = COMPLETED.WORD : FIRST.WORD[I,1]
                              END ELSE EXIT
                           NEXT I
*
                           COMMAND = CURRENT.COMMAND : COMPLETED.WORD
                           CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
                           PRINT BOTTOM :
                           PRINT SHELL.PROMPT :
                           PRINT COMMAND : CLEAR.REST.OF.SCREEN :
*
                           PRINT.SHELL.PROMPT = FALSE
                           CONTINUE
                        END
*
                     CASE TRUE
                        IF RECORDS.SELECTED = 1 THEN
                           READNEXT ITEM.ID ELSE ITEM.ID = ''
*
                           PRINT
                           PRINT 'ID: ': ITEM.ID
                           PRINT BOTTOM :
                           PRINT SHELL.PROMPT :
                           PRINT CURRENT.COMMAND : ITEM.ID : CLEAR.REST.OF.SCREEN :
*
                           IF VERB = 'MAN' OR VERB = 'RUN' OR FILE.LOOKUP = 'KP' THEN
                              COMMAND = CURRENT.COMMAND : ITEM.ID
                           END ELSE
                              COMMAND = CURRENT.COMMAND : '"' : ITEM.ID : '"'
                           END
*
                           CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                           PRINT.SHELL.PROMPT = FALSE
                           CONTINUE
*
                        END ELSE IF RECORDS.SELECTED = 0 THEN
                           CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                           PRINT.SHELL.PROMPT = FALSE
                           CONTINUE
*
                        END ELSE
                           PRINT
                           FIRST.WORD = ''
                           LAST.WORD = ''
                           LOOP
                              READNEXT ITEM.ID ELSE ITEM.ID = ''
                           UNTIL ITEM.ID = '' DO
                              PRINT 'ID: ' : ITEM.ID
                              IF FIRST.WORD = '' THEN FIRST.WORD = ITEM.ID
                              LAST.WORD = ITEM.ID
                           REPEAT
*
                           COMPLETED.WORD = ''
                           FOR I = 1 TO LEN(FIRST.WORD)
                              IF FIRST.WORD[I,1] = LAST.WORD[I,1] THEN
                                 COMPLETED.WORD = COMPLETED.WORD : FIRST.WORD[I,1]
                              END ELSE EXIT
                           NEXT I
*
                           COMMAND = CURRENT.COMMAND : COMPLETED.WORD
                           CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
                           PRINT BOTTOM :
                           PRINT SHELL.PROMPT :
                           PRINT COMMAND : CLEAR.REST.OF.SCREEN :
                           PRINT.SHELL.PROMPT = FALSE
                           CONTINUE
                        END
*
                  END CASE
               CASE TRUE
                  PRINT.SHELL.PROMPT = FALSE
                  CONTINUE
            END CASE
         END
*
         IF COMMAND = '' THEN
            PRINT
            CONTINUE
         END
*
* ADD COMMAND TO TRUE HISTORY
*
         COMMAND.STACK<TRUE.HISTORY> = INSERT(COMMAND.STACK<TRUE.HISTORY>, 1, 1;COMMAND)
         IF NSH.HISTORY.OPENED THEN
            WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
         END
*
         ADD.TO.STACK = TRUE
*
* COMMAND STACK MANIPULATION
*
         IF COMMAND[1,1] = '.' THEN
            COMMAND.NUMBER = COMMAND[3, LEN(COMMAND)]
            PROCEED.STACK.OPERATION = FALSE
*
            IF COMMAND[2,1] = 'A' OR COMMAND[2,1] = 'C' OR COMMAND[2,1] = 'U' THEN
               PROCEED.STACK.OPERATION = TRUE
*
* NUMBER AFTER COMMAND STACK MANIPULATOR
*
            END ELSE
               CONVERT ',' TO @AM IN COMMAND.NUMBER
               COMMAND.NUMBERS = COMMAND.NUMBER
               COMMAND.NUMBER = COMMAND.NUMBER<1>
*
               IF COMMAND.NUMBER = '' THEN
                  COMMAND.NUMBER = 1
                  ADD.TO.STACK = FALSE
                  COMMAND.NUMBERS = COMMAND.NUMBER
               END
*
               IF NUM(COMMAND.NUMBER) THEN
                  IF COMMAND.NUMBER <= COMMAND.STACK.LENGTH THEN
                     PROCEED.STACK.OPERATION = TRUE
                  END ELSE IF COMMAND[2,1] # 'L' THEN
                     PRINT
                     PRINT 'NSH: Error - Command stack is: ' : COMMAND.STACK.LENGTH
                  END
               END
            END
*
            BEGIN CASE
               CASE PROCEED.STACK.OPERATION = FALSE
                  COMMAND = ''
                  CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
               CASE COMMAND[2,1] = 'L'
                  PRINT
                  COMMAND = ''
                  CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  MAX = 20
                  IF COMMAND.STACK.LENGTH <= MAX THEN
                     MAX = COMMAND.STACK.LENGTH
                  END
                  FOR I = MAX TO 1 STEP -1
                     IF I < 10 THEN
                        PRINT '0' : I : ' ' : COMMAND.STACK<HISTORY,I>
                     END ELSE
                        PRINT I : ' ' : COMMAND.STACK<HISTORY,I>
                     END
                  NEXT I
                  CONTINUE
*
               CASE COMMAND[2,1] = 'X'
                  COMMAND = ''
                  CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  IF PROCEED.STACK.OPERATION THEN
                     NUMBER.OF.COMMANDS = DCOUNT(COMMAND.NUMBERS,@AM)
                     FOR I = 1 TO NUMBER.OF.COMMANDS
                        COMMAND.NUMBER = COMMAND.NUMBERS<I>
                        IF NUM(COMMAND.NUMBER) AND COMMAND.NUMBER <= COMMAND.STACK.LENGTH THEN
                           COMMAND<-1> = COMMAND.STACK<HISTORY,COMMAND.NUMBER>
                        END ELSE
                           EXIT
                        END
                     NEXT I
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  END
*
               CASE COMMAND[2,1] = 'D'
                  COMMAND = ''
                  CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  IF PROCEED.STACK.OPERATION THEN
                     PRINT
                     COMMAND.STACK<HISTORY> = DELETE(COMMAND.STACK,1,COMMAND.NUMBER)
                     IF NSH.HISTORY.OPENED THEN
                        WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
                     END
                     PRINT 'NSH: Deleted #' : COMMAND.NUMBER : ' from stack.' :
                  END
*
               CASE COMMAND[2,1] = 'R'
                  COMMAND = ''
                  CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  IF PROCEED.STACK.OPERATION THEN
                     COMMAND = COMMAND.STACK<HISTORY,COMMAND.NUMBER>
                     COMMAND.STACK<HISTORY> = DELETE(COMMAND.STACK,1,COMMAND.NUMBER)
                     COMMAND.STACK<HISTORY> = INSERT(COMMAND.STACK<1>, 1, 1;COMMAND)
                     PRINT
                     IF COMMAND.NUMBER < 10 THEN
                        PRINT '0' : COMMAND.NUMBER : ' ' : COMMAND :
                     END ELSE
                        PRINT COMMAND.NUMBER : ' ' : COMMAND :
                     END
                     IF NSH.HISTORY.OPENED THEN
                        WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
                     END
                     COMMAND = ''
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  END
*
               CASE COMMAND[2,1] = 'A'
                  IF PROCEED.STACK.OPERATION THEN
                     APPEND = COMMAND[3, LEN(COMMAND)]
                     COMMAND.STACK<HISTORY,1> = COMMAND.STACK<HISTORY,1> : APPEND
                     PRINT
                     IF COMMAND.NUMBER < 10 THEN
                        PRINT '0' : COMMAND.NUMBER : ' ' : COMMAND.STACK<HISTORY,1> :
                     END ELSE
                        PRINT COMMAND.NUMBER : ' ' : COMMAND.STACK<HISTORY,1> :
                     END
                     COMMAND = ''
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  END
*
               CASE COMMAND[2,1] = 'U'
                  IF PROCEED.STACK.OPERATION THEN
                     COMMAND.STACK<HISTORY,1> = OCONV(COMMAND.STACK<HISTORY,1>, 'MCU')
                     PRINT
                     IF COMMAND.NUMBER < 10 THEN
                        PRINT '0' : COMMAND.NUMBER : ' ' : COMMAND.STACK<HISTORY,1> :
                     END ELSE
                        PRINT COMMAND.NUMBER : ' ' : COMMAND.STACK<HISTORY,1> :
                     END

                     COMMAND = ''
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  END
*
               CASE COMMAND[2,1] = 'C'
                  IF PROCEED.STACK.OPERATION THEN
                     DELIMITER = '/'
                     NUMBER.OF.DELIMITERS = COUNT(COMMAND, DELIMITER)
*
                     PROCEED = TRUE
*
* CHECK MULTIPLE DELIMITER TYPES
*
                     IF NUMBER.OF.DELIMITERS < 2 OR NUMBER.OF.DELIMITERS > 3 THEN
                        DELIMITER = '!'
                        NUMBER.OF.DELIMITERS = COUNT(COMMAND, DELIMITER)
                        IF NUMBER.OF.DELIMITERS < 2 OR NUMBER.OF.DELIMITERS > 3 THEN
                           PRINT
                           PRINT 'NSH: There needs to be exactly 2 delimiters.' :
                           PROCEED = FALSE
                        END
                     END
*
                     IF PROCEED THEN
                        CHANGE.STACK.POINTER = 1
*
                        NUM1 = FIELD(COMMAND,DELIMITER,1)
*
                        IF LEN(NUM1) = 2 THEN
                           CHANGE.STACK.POINTER = 1
                        END ELSE
                           NUM1 = NUM1[3,99]
                           IF NUM(NUM1) THEN
                              CHANGE.STACK.POINTER = NUM1
                           END ELSE
                              CHANGE.STACK.POINTER = 1
                           END
                        END
*
                        IF CHANGE.STACK.POINTER > COMMAND.STACK.LENGTH THEN
                           PRINT
                           PRINT 'NSH: Command does not exist.' :
                           PROCEED = FALSE
                        END
*
                        IF PROCEED THEN
                           STRING1 = FIELD(COMMAND,DELIMITER,2)
                           STRING2 = FIELD(COMMAND,DELIMITER,3)
*
                           IF NUMBER.OF.DELIMITERS = 2 THEN
                              HOW.MANY = 1
                           END ELSE
                              HOW.MANY = FIELD(COMMAND,'/',4)
                              IF HOW.MANY = 'G' THEN
                                 HOW.MANY = -1
                              END
                              IF NOT(NUM(HOW.MANY)) THEN
                                 PRINT
                                 PRINT 'NSH: Number of replaces should be a number.' :
                                 PROCEED = FALSE
                              END
                           END
*
                           IF PROCEED THEN
                              COMMAND = EREPLACE(COMMAND.STACK<HISTORY,CHANGE.STACK.POINTER>,STRING1,STRING2,HOW.MANY)
                              CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
                              PRINT
                              IF CHANGE.STACK.POINTER < 10 THEN
                                 PRINT '0' : CHANGE.STACK.POINTER : ' ' : COMMAND :
                              END ELSE
                                 PRINT CHANGE.STACK.POINTER : ' ' : COMMAND :
                              END
*
                              COMMAND.STACK<HISTORY,CHANGE.STACK.POINTER> = COMMAND
                           END
                        END
                     END
                     COMMAND = ''
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                  END
*
               CASE TRUE
                  PRINT
                  PRINT 'NSH: Invalid command stack manipulation.' :
                  COMMAND = ''
                  CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
            END CASE
         END
*
* EXECUTE SHELL COMMANDS
*
         IF COMMAND = '!' THEN
            $IFDEF PLATFORM.LINUX
                $IFDEF DATABASE.UV
                    PRINT
                    EXECUTE 'SH'
                    COMMAND = ''
                    CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                $ENDIF
            $ENDIF
*
         END ELSE IF COMMAND[1,1] = '!' THEN
            COMMAND = COMMAND[2,LEN(COMMAND)]
            $IFDEF PLATFORM.LINUX
                $IFDEF DATABASE.UV
                    EXECUTE 'SH -c ' : '"' : COMMAND : '"'
                $ENDIF
                $IFDEF DATABASE.D3
                    EXECUTE '!' : COMMAND
                $ENDIF
            $ENDIF
            $IFDEF PLATFORM.WINDOWS
                EXECUTE '! ' : '"' : COMMAND : '"'
            $ENDIF
            COMMAND = ''
            CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
         END
*
         PRINT
*
         VERB = FIELD(COMMAND,' ',1)
*
* EXECUTE NSH VERBS
*
         BEGIN CASE
            CASE COMMAND = 'Q'
               COMMAND = ''
               CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
               EXIT
*
            CASE COMMAND = 'CLEAR'
               COMMAND = 'CLR'
               CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
            CASE COMMAND[1,3] = 'LS '
               COMMAND = CHANGE(COMMAND, 'LS ', 'LIST ', 1)
               CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
            CASE COMMAND = 'HISTORY'
               FOR I = DCOUNT(COMMAND.STACK<TRUE.HISTORY>,@VM) TO 1 STEP -1
                  IF I < 10 THEN
                     PRINT '0' : I : ' ' : COMMAND.STACK<TRUE.HISTORY,I>
                  END ELSE
                     PRINT I : ' ' : COMMAND.STACK<TRUE.HISTORY,I>
                  END
               NEXT I
*
               COMMAND = ''
               CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
               CONTINUE
*
* HELP MANIPULATION
*
            CASE VERB = 'MAN'
               COMMAND.STACK<HISTORY> = INSERT(COMMAND.STACK<HISTORY>, 1, 1;COMMAND)
               IF NSH.HISTORY.OPENED THEN
                  WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
               END
*
               ACTION = FIELD(COMMAND,' ',2)
               BASIC.VERB = FIELD(COMMAND,' ',3)
*
* Check If MAN is for BASIC or SYSTEM
*
               BEGIN CASE
                  CASE ACTION = '' AND NOT(SYS.HELP.OPENED)
                     PRINT "NSH: SYS.HELP not available"
                     CONTINUE
*
                  CASE ACTION = 'BASIC' AND NOT(BASIC.HELP.OPENED)
                     PRINT "NSH: BASIC.HELP not available"
                     CONTINUE
*
                  CASE ACTION = ''
                     EXECUTE 'SORT SYS.HELP @ID ID-SUPP'
                     COMMAND = ''
                     CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                     CONTINUE
*
                  CASE ACTION = 'BASIC' AND BASIC.VERB # ''
                     READV ACTION.TYPE FROM BASIC.HELP.FILE,BASIC.VERB,2 ELSE ACTION.TYPE = ''
*
                     IF ACTION.TYPE = '' THEN
                        PRINT 'NSH: BASIC keyword not in manual: ' : BASIC.VERB
                        COMMAND = ''
                        CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                        CONTINUE
                     END ELSE
                        PRINT 'NSH: BASIC Help: ' : BASIC.VERB
                        EXECUTE 'LIST BASIC.HELP ' : '"' : BASIC.VERB : '"'
                        COMMAND = ''
                        CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                        CONTINUE
                     END
*
                  CASE TRUE
                     IF NOT(SYS.HELP.OPENED) THEN
                        PRINT "NSH: SYS.HELP not available"
                        CONTINUE
                     END
*
                     READV ACTION.TYPE FROM SYS.HELP.FILE,ACTION,2 ELSE ACTION.TYPE = ''
*
                     IF ACTION.TYPE = '' THEN
                        PRINT 'NSH: System keyword not in manual: ' : ACTION
                        COMMAND = ''
                        CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                        CONTINUE
                     END ELSE
                        PRINT 'NSH: Help: ' : ACTION
                        EXECUTE 'CT SYS.HELP ' : ACTION : ' (S)'
                        COMMAND = ''
                        CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
                        CONTINUE
                     END
*
               END CASE
*
         END CASE
*
         IF ADD.TO.STACK AND COMMAND # '' THEN
            NUMBER.OF.COMMANDS = DCOUNT(COMMAND,@AM)
            FOR I = 1 TO NUMBER.OF.COMMANDS
               COMMAND.STACK<HISTORY> = INSERT(COMMAND.STACK<HISTORY>, 1, 1;COMMAND<I>)
            NEXT I
            IF NSH.HISTORY.OPENED THEN
               WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
            END
         END
*
         NUMBER.OF.COMMANDS = DCOUNT(COMMAND,@AM)
         FOR I = 1 TO NUMBER.OF.COMMANDS
            SERIES<-1> = COMMAND<I>
         NEXT I
*
* EXECUTE CUSTOM COMMANDS
*
         IF VERB = 'LOGTO' THEN
            $IFDEF DATABASE.UV
                EXECUTE SERIES
                ACCOUNT.NAME = @WHO
            $ENDIF
            $IFDEF DATABASE.D3
                EXECUTE SERIES : ' (f'
                ACCOUNT.NAME = @ACCOUNT
            $ENDIF
*
         END ELSE IF VERB = 'SEARCH' THEN
            $IFDEF DATABASE.UV
                SERIES.LENGTH = DCOUNT(SERIES,@AM)
                IF DCOUNT(COMMAND,' ') >= 3 THEN
                    COMMAND = CHANGE(COMMAND,'"','')
                    SEARCH.FILE = FIELD(COMMAND,' ',2)
                    SEARCH.KEY = TRIM(COMMAND[INDEX(COMMAND,SEARCH.FILE,1)+LEN(SEARCH.FILE)+1,9999])
*
                    PRINT SEARCH.KEY
                    SERIES<SERIES.LENGTH> = 'SEARCH ' : SEARCH.FILE
                    IF SERIES.LENGTH = 2 THEN 
                        DATA ''
                    END
                    DATA SEARCH.KEY
                    DATA ''
                END
*
                SERIES<-1> = 'SAVE-LIST ' : USER.NAME : '.' : PORT.NUMBER : '.LIST'
                EXECUTE SERIES CAPTURING RESULTS
*
                PRINT
                MESSAGE = RESULTS<DCOUNT(RESULTS, @AM)-1>
                PRINT MESSAGE
                IF INDEX(MESSAGE,'0 record',1) = 0 THEN
                    SERIES = 'GET-LIST ' : USER.NAME : '.' : PORT.NUMBER : '.LIST'
                END ELSE
                    SERIES = ''
                END
            $ENDIF
*
            $IFDEF DATABASE.D3
                SERIES.LENGTH = DCOUNT(SERIES,@AM)
                SERIES<SERIES.LENGTH> = CHANGE(SERIES<SERIES.LENGTH>,'SEARCH','FIND')
*
                IF DCOUNT(COMMAND,' ') >= 3 THEN
                    COMMAND = CHANGE(COMMAND,'"','')
                    SEARCH.FILE = FIELD(COMMAND,' ',2)
                    SEARCH.KEY = TRIM(COMMAND[INDEX(COMMAND,SEARCH.FILE,1)+LEN(SEARCH.FILE)+1,9999])
*
                    PRINT SEARCH.KEY
                    SERIES<SERIES.LENGTH> = 'FIND ' : SEARCH.FILE
                    DATA SEARCH.KEY
                    DATA ''
                    DATA USER.NAME : '.' : PORT.NUMBER : '.LIST'
                    EXECUTE SERIES CAPTURING RESULTS
*
                END ELSE
                    EXECUTE SERIES
                END
*
                SERIES = 'GET-LIST ' : USER.NAME : '.' : PORT.NUMBER : '.LIST'
                EXECUTE SERIES
            $ENDIF
*
         END ELSE IF VERB = 'SAVE-LIST' THEN
            EXECUTE SERIES CAPTURING RESULTS
            PRINT
            PRINT RESULTS<4>
*
         END ELSE IF VERB = 'DATECONV' THEN
            LOOP
                PRINT 'Date: ' :
                INPUT DATE
            UNTIL DATE = '' OR OCONV(DATE,"MCU") = 'Q' DO
                IF DATE = 'TODAY' THEN
                    PRINT 'Date: ' : DATE()
                    PRINT OCONV(DATE(),'D')
*
                END ELSE IF LEN(DATE) = 5 THEN
                    PRINT OCONV(DATE,'D')
*
                END ELSE
                    PRINT OCONV(DATE,'DI')
                END
            REPEAT
*
         END ELSE IF VERB = 'TIMECONV' THEN
            LOOP
                PRINT 'Time: ' :
                INPUT TIME
            UNTIL TIME = '' OR OCONV(TIME,"MCU") = 'Q' DO
                IF TIME = 'NOW' THEN
                    PRINT 'Time: ' : TIME()
                    PRINT OCONV(TIME(),'MT')
*
                END ELSE IF LEN(TIME) = 10 THEN
                    PRINT OCONV(TIME+0,'MT')
*
                END ELSE
                    PRINT OCONV(TIME,'T')
                END
            REPEAT
*
        END ELSE IF VERB = 'NSHUP' THEN
            NSHUP.COMMAND = COMMAND[INDEX(COMMAND,' ',1)+1,9999]
*
            SERIES = ''
            COMMAND = ''
*
            BEGIN CASE
                CASE NSHUP.COMMAND = 'SHOW'
                    PRINT 'NSH: Version ' : VERSION
*
                CASE NSHUP.COMMAND = 'CHECK' OR NSHUP.COMMAND = 'UPDATE'
                    $IFDEF PLATFORM.LINUX
                        NSH.CHECK.COMMAND = 'curl -s ' : NSH.URL : ' | grep "MAJOR.VERSION =" -A2' 
                        EXECUTE "SH -c '" : NSH.CHECK.COMMAND : "'" CAPTURING RESULTS
                    $ENDIF
                    $IFDEF PLATFORM.WINDOWS
                        PRINT 'NSH: Version checks and auto update not supported on Windows.'
                        PRINT 'NSH: Please visit: https://github.com/Krowemoh/NovaShell'
                        CONTINUE
                    $ENDIF
*
                    REMOTE.MAJOR.VERSION = FIELD(RESULTS<1>,"'",2)
                    REMOTE.MINOR.VERSION = FIELD(RESULTS<2>,"'",2)
                    REMOTE.PATCH.VERSION = FIELD(RESULTS<3>,"'",2)
*
                    REMOTE.VERSION = REMOTE.MAJOR.VERSION : '.' : REMOTE.MINOR.VERSION : '.' : REMOTE.PATCH.VERSION
*
                    PRINT 'NSH: Current version: ' : VERSION
*
                    IF REMOTE.MAJOR.VERSION > MAJOR.VERSION OR REMOTE.MINOR.VERSION > MINOR.VERSION OR REMOTE.PATCH.VERSION > PATCH.VERSION THEN
                        PRINT 'NSH: Update to ' : REMOTE.VERSION : ' available.' 
*
                        IF NSHUP.COMMAND # 'UPDATE' THEN
                            CONTINUE
                        END
*
                        PRINT 'Do you want to update? (y/n) ' : 
                        INPUT ANS
*
                        IF ANS # 'Y' THEN
                            CONTINUE
                            PRINT 'NSH: No changes made.'
                        END
*
                        OPEN '',VOC TO VOC.FILE ELSE 
                            PRINT 'Unable to open file: ' : VOC : ' - Press RETURN':
                            CONTINUE 
                        END
*
                        READ NSH.MD.ITEM FROM VOC.FILE,'NSH' ELSE
                            PRINT 'NSH: NSH not found in master dictionary.'
                            CONTINUE 
                        END
*
                        PRINT 'Updating...'
*
                        $IFDEF DATABASE.UV
                            BP = CHANGE(NSH.MD.ITEM<9>,'.O','',1)
*
                            IF INDEX(BP,'/',1) # 0 THEN
                                SERIES = ''
                                PRINT 'NSH: Update from the original NSH location.'
                                PRINT 'NSH: Location: ' : BP
                                PRINT 'NSH: No changes made.'
                                CONTINUE
                            END
*
                            OPEN '',BP TO BP.FILE ELSE 
                                PRINT 'Unable to open file: ' : BP : ' - Press RETURN':
                                CONTINUE 
                            END
*
                            NSH.GET.COMMAND = 'curl -s ' : NSH.URL 
                            EXECUTE "SH -c '" : NSH.GET.COMMAND : "'" CAPTURING REMOTE.NSH.FILE 
*
                            WRITE REMOTE.NSH.FILE ON BP.FILE,'NSH'
*
                            EXECUTE 'BASIC ' : BP : ' NSH' 
*
                            CHAIN 'NSH'
                        $ENDIF
                        $IFDEF
                            PRINT 'NSH: Auto update not supported on D3.'
                            PRINT 'NSH: Please visit: https://github.com/Krowemoh/NovaShell'
                        $ENDIF
*
                    END ELSE IF REMOTE.VERSION = VERSION THEN 
                        PRINT 'NSH: NSH is up to date.'
*
                    END ELSE
                        PRINT 'NSH: Remote version: ' : REMOTE.VERSION
                        PRINT 'NSH: Current version is ahead.'
                    END
*
                CASE NSHUP.COMMAND = 'ENABLE STARTUP'
                    OPEN '',VOC TO VOC.FILE THEN
                        READ POSSIBLE.STARTUP.MATRIX FROM VOC.FILE,USER.NAME THEN
                            IF POSSIBLE.STARTUP.MATRIX = STARTUP.MATRIX THEN
                                PRINT 'NSH: NSH is already enabled on startup.'
                            END ELSE
                                PRINT 'NSH: Did not enable NSH on startup.'
                                PRINT 'NSH: ' : VOC : ' entry for ' : USER.NAME : ' already exists.'
                            END
*
                        END ELSE
                            WRITE STARTUP.MATRIX ON VOC.FILE,USER.NAME
                            PRINT 'NSH: Enabled NSH on startup.'
                        END
                    END
*
                CASE NSHUP.COMMAND = 'DISABLE STARTUP'
                    OPEN '',VOC TO VOC.FILE THEN
                        READU POSSIBLE.STARTUP.MATRIX FROM VOC.FILE,USER.NAME THEN
                            IF POSSIBLE.STARTUP.MATRIX = STARTUP.MATRIX THEN
                                DELETE VOC.FILE,USER.NAME
                                PRINT 'NSH: Disabled NSH from running on startup.'
                            END
                        END ELSE
                            PRINT 'NSH: NSH is not enabled on startup.'
                        END
                    END
*
                CASE TRUE
                    PRINT 'NSH: Invalid NSHUP command.'
            END CASE
*
        END ELSE IF VERB = 'PRINT' THEN
            PRINT.COMMAND = FIELD(COMMAND,' ',2)
*
            IF PRINT.COMMAND[1,5] = 'OCONV' OR PRINT.COMMAND[1,5] = 'ICONV' THEN
                COMMAND = CHANGE(COMMAND,'"','')
*
                START.BRACKET = INDEX(COMMAND,'(',1)
                END.BRACKET = INDEX(COMMAND,')',1)
*
                COMMAND = COMMAND[START.BRACKET+1, END.BRACKET-START.BRACKET-1]
*
                VALUE = FIELD(COMMAND,',',1) 
                CONV = FIELD(COMMAND,',',2) 
*
                IF VERB[1,5] = 'OCONV' THEN
                    PRINT OCONV(VALUE,CONV)
                END ELSE 
                    PRINT ICONV(VALUE,CONV)
                END
*
            END ELSE IF PRINT.COMMAND = '@ACCOUNT' THEN
                PRINT @ACCOUNT
            END ELSE IF PRINT.COMMAND = '@WHO' THEN
                PRINT @WHO
            END ELSE IF PRINT.COMMAND = '@LOGNAME' THEN
                PRINT @LOGNAME
            END ELSE IF PRINT.COMMAND = '@USER.NO' THEN
                PRINT @USER.NO
            END ELSE IF PRINT.COMMAND = '@TTY' THEN
                PRINT @TTY
            END ELSE IF PRINT.COMMAND = 'DATE()' THEN
                PRINT DATE()
            END ELSE IF PRINT.COMMAND = 'TIME()' THEN
                PRINT TIME()
            END ELSE
                PRINT 'NSH: Invalid print command.'
            END
*
         END ELSE IF VERB = 'VERSION' THEN
            PRINT '**************************************'
            PRINT 'NSH: Version ' : VERSION
            $IFDEF PLATFORM.LINUX
                PRINT
                PRINT 'NSH: cat /etc/os-release'
                PRINT '**************************************'
                EXECUTE 'SH -c "cat /etc/os-release"'
            $ENDIF
            $IFDEF DATABASE.UV
                PRINT
                PRINT 'NSH: CT MD RELLEVEL' 
                PRINT '**************************************' :
                EXECUTE 'CT MD RELLEVEL'
            $ENDIF
*
         END ELSE
            EXECUTE SERIES
         END
*
         LOCATE(VERB,SERIES.VERBS,1;ANY.POS) ELSE
            SERIES = ''
         END
*
         COMMAND = ''
         CURSOR.POSITION = LEN(SHELL.PROMPT) + LEN(COMMAND)
*
      REPEAT
*
      IF NSH.HISTORY.OPENED THEN
         WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
      END
*
      PRINT 'NSH: BYE'
*
* END OF PROGRAM.
*
   END

