*
    GIT.FILENAME = 'NSH'
    GIT.REPO = 'https://github.com/Krowemoh/nsh.git'
*
* COMPILER DIRECTIVES
*
*
*ASI********************************************************************
*                                                                      *
* Create Date  Req#  Who  Description                                  *
* 23 OCT 2021  N/A   NT   NovaShell v0.1                               *
* 07 NOV 2021  N/A   NT   NovaShell v0.2                               *
* 24 MAR 2022  N/A   NT   NovaShell v0.3                               *
* 31 MAY 2022  N/A   NT   NovaShell v0.4                               *
* 20 JUN 2022  N/A   NT   NovaShell v0.5                               *
* 24 JUN 2022  N/A   NT   NovaShell v0.6                               *
*                                                                      *
************************************************************************
* Special Instructions                                                 *
*                                                                      *
************************************************************************
* Change History                                                       *
*                                                                      *
* Change Date  Req#  Who  Description                                  *
* 07 NOV 2021  N/A   NT   Added Dynamic Terminal Escape Codes          *
* 24 MAR 2022  N/A   NT   Add History Search with Arrow Keys           *
*                         Enhance Autocomplete to Complete Substring   *
*                         Don't Assume Files are Opened Successfully   *
*                         Account Specific History Files               *
*                         Auto Create NSH-HISTORY-FILE in Accounts     *
*                         Clean Up SEARCH                              *
*                         Allow multiple .X Command Numbers            *
* 31 MAY 2022  N/A   NT   Move NSH-HISTORY-FILE to /tmp/               *
*                         Remove Account Specific History              *
* 10 JUN 2022  N/A   NT   Add Support for D3 and Windows               *
* 20 JUN 2022  N/A   NT   Add a date and time conversion utility       *
* 20 JUN 2022  N/A   NT   D3 - Breaking Change - Search = FIND         *
*                         You cannot use the native search in D3       *
* 24 JUN 2022  N/A   NT   Added color support - xterm                  *
*                                                                      *
************************************************************************
*
    EXECUTE 'TERM xterm'
*
* VERSION
*
    VERSION = '6'
*
* NSH MASTER URL
*
    NSH.URL = 'https://raw.githubusercontent.com/Krowemoh/NovaShell/main/NSH'
*
* CONSTANTS
*
    @USER1 = 'NSH'
    @USER2 = 'NSH'
*
    BOTTOM = @(0,66)
*
    EQU TRUE TO 1
    EQU FALSE TO 0
*
* NSH FLAGS
*
    SHOW.IP.FLAG = FALSE
    IF INDEX(@SENTENCE,"--SHOW-IP",1) # 0 THEN
        SHOW.IP.FLAG = TRUE
    END
*
    STARTUP.MATRIX = ''
    STARTUP.MATRIX<-1> = 'PQ'
    STARTUP.MATRIX<-1> = 'HTERM xterm-256color'
    STARTUP.MATRIX<-1> = 'P'
    STARTUP.MATRIX<-1> = 'HNSH'
*
* SYSTEM FILE FOR UV ACCOUNTS
*
        LOGTO.FILENAME = 'UV.ACCOUNT'
*
    LOGTO.OPENED = TRUE
    OPEN '',LOGTO.FILENAME TO LOGTO.FILE ELSE
        PRINT 'NSH: Unable to open file: ' : LOGTO.FILENAME
        LOGTO.OPENED = FALSE
    END
*
* SYSTEM FILE FOR VERBS
*
    NEW.ACC.OPENED = TRUE
    OPEN '','NEWACC' TO NEWACC.FILE ELSE
        PRINT 'NSH: Unable to open file: NEWACC'
        NEW.ACC.OPENED = FALSE
    END
*
* SYSTEM FILE FOR HELP PAGES
*
    SYS.HELP.OPENED = TRUE
    OPEN '','SYS.HELP' TO SYS.HELP.FILE ELSE
        PRINT 'NSH: Unable to open file: SYS.HELP'
        SYS.HELP.OPENED = FALSE
    END
*
* SYSTEM FILE FOR BASIC PAGES
*
    BASIC.HELP.OPENED = TRUE
    OPEN '','BASIC.HELP' TO BASIC.HELP.FILE ELSE
        PRINT 'NSH: Unable to open file: BASIC.HELP'
        BASIC.HELP.OPENED = FALSE
    END
*
* SET VOC
*
        VOC = 'VOC'
*
* FILE FOR SAVING COMMAND HISTORY
*
    NSH.HISTORY.OPENED = TRUE
    OPEN '','NSH-HISTORY-FILE' TO NSH.HISTORY.FILE ELSE
        OPEN '',VOC TO VOC.FILE THEN
            NSH.ENTRY = ''
                    NSH.ENTRY<1> = 'F'
                    NSH.ENTRY<2> = '/tmp/.nsh/'
                    NSH.ENTRY<3> = '/tmp/.nsh/'
*
            WRITE NSH.ENTRY ON VOC.FILE,'NSH-HISTORY-FILE'
*
            OPEN '','NSH-HISTORY-FILE' TO NSH.HISTORY.FILE ELSE
                        EXECUTE 'SH -c "mkdir -p /tmp/.nsh/"'
                OPEN '','NSH-HISTORY-FILE' TO NSH.HISTORY.FILE ELSE
                    NSH.HISTORY.OPENED = FALSE
                END
            END
        END ELSE
            PRINT 'NSH: Unable to open file: VOC'
            NSH.HISTORY.OPENED = FALSE
        END
    END
*
* SHELL INITIALIZATION
*
        USER.NAME = @ACCOUNT
        PORT.NUMBER = @USERNO
        ACCOUNT.NAME = @WHO
*
*
* NSH USER SPECIFIC INITIALIZATION
*
    NSH.PROFILE.NAME = USER.NAME : '.nsh_profile'
    COMMAND.HISTORY.FILE.NAME = USER.NAME : '.nsh_history'
*
    IF NSH.HISTORY.OPENED THEN
        READ COMMAND.STACK FROM NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME ELSE COMMAND.STACK = ''
        READ NSH.PROFILE FROM NSH.HISTORY.FILE, NSH.PROFILE.NAME ELSE NSH.PROFILE = ''
*
    END ELSE
        COMMAND.STACK = ''
        NSH.PROFILE = ''
    END
*
    PROMPT ''
*
* CLEARING LINES
*
    CLEAR.SCREEN = @(-1)
    CLEAR.REST.OF.SCREEN = @(-3)
    CLEAR.REST.OF.LINE = @(-4)
    CLEAR.LINE = @(0) : CLEAR.REST.OF.LINE
*
    EQU HISTORY TO 1
    EQU TRUE.HISTORY TO 2
*
    EQU KEY.CTRL.A TO CHAR(1)
    EQU KEY.CTRL.C TO CHAR(3)
    EQU KEY.CTRL.F TO CHAR(6)
    EQU KEY.ESCAPE TO CHAR(27)
    EQU KEY.BACKSPACE TO CHAR(8)
    EQU KEY.TAB TO CHAR(9)
    EQU KEY.LINE.FEED TO CHAR(10)
    EQU KEY.CARRIAGE.RETURN TO CHAR(13)
    EQU KEY.EXCLAIMATION.MARK TO CHAR(33)
    EQU KEY.DELETE TO CHAR(127)
*
    EQU ESCAPE.CODE TO CHAR(27)
*
* MAKE TERMINAL MAX SIZE BASED ON WINTEGRATE
*
    EXECUTE 'TERM 132,66'
*
* TERMINAL INITIALIZATION
*
        TERMINAL.CODES = TERMINFO(0)
        TERMINAL.TYPE = FIELD(TERMINAL.CODES<1>,'|',1)
*
        IF TERMINAL.TYPE = 'vp' THEN
            PRINT 'NSH: Re-mapped susp to ^B (Ctrl B)'
                EXECUTE 'SH -c "stty susp ^B"'
            TERMINAL.TYPE = 'viewpoint'
        END
*
        UP.ARROW = 'OA'
        DOWN.ARROW = 'OB'
        LEFT.ARROW = 'OD'
        RIGHT.ARROW = 'OC'
*
*
* SET UP TERMINAL COLORS
*
    RESET.COLOR = ''
    BLACK = ''
    RED = ''
    GREEN = ''
    YELLOW = ''
    BLUE = ''
    MAGENTA = ''
    CYAN = ''
    WHITE = ''
*
    BRIGHTBLACK = ''
    BRIGHTRED = ''
    BRIGHTGREEN = ''
    BRIGHTYELLOW = ''
    BRIGHTBLUE = ''
    BRIGHTMAGENTA = ''
    BRIGHTCYAN = ''
    BRIGHTWHITE = ''
*
    IF TERMINAL.TYPE = 'xterm' OR TERMINAL.TYPE = 'xterm-256color' THEN
        RESET.COLOR = ESCAPE.CODE : '[0m'
*
        BLACK = ESCAPE.CODE : '[30m'
        RED = ESCAPE.CODE : '[38;5;1m'
        GREEN = ESCAPE.CODE : '[38;5;2m'
        YELLOW = ESCAPE.CODE : '[38;5;3m'
        BLUE = ESCAPE.CODE : '[38;5;4m'
        MAGENTA = ESCAPE.CODE : '[38;5;5m'
        CYAN = ESCAPE.CODE : '[38;5;6m'
        WHITE = ESCAPE.CODE : '[38;5;7m'
*
        BRIGHTBLACK = ESCAPE.CODE : '[38;5;8m'
        BRIGHTRED = ESCAPE.CODE : '[38;5;9m'
        BRIGHTGREEN = ESCAPE.CODE : '[38;5;10m'
        BRIGHTYELLOW = ESCAPE.CODE : '[38;5;11m'
        BRIGHTBLUE = ESCAPE.CODE : '[38;5;12m'
        BRIGHTMAGENTA = ESCAPE.CODE : '[38;5;13m'
        BRIGHTCYAN = ESCAPE.CODE : '[38;5;14m'
        BRIGHTWHITE = ESCAPE.CODE : '[38;5;15m'
        RESET.COLOR = ESCAPE.CODE : '[0m'
*
        BACKGROUND.BLACK = ESCAPE.CODE : '[48;5;0m'
        BACKGROUND.RED = ESCAPE.CODE : '[48;5;1m'
        BACKGROUND.GREEN = ESCAPE.CODE : '[48;5;2m'
        BACKGROUND.YELLOW = ESCAPE.CODE : '[48;5;3m'
        BACKGROUND.BLUE = ESCAPE.CODE : '[48;5;4m'
        BACKGROUND.MAGENTA = ESCAPE.CODE : '[48;5;5m'
        BACKGROUND.CYAN = ESCAPE.CODE : '[48;5;6m'
        BACKGROUND.WHITE = ESCAPE.CODE : '[48;5;7m'
*
        BACKGROUND.BRIGHTBLACK = ESCAPE.CODE : '[48;5;8m'
        BACKGROUND.BRIGHTRED = ESCAPE.CODE : '[48;5;9m'
        BACKGROUND.BRIGHTGREEN = ESCAPE.CODE : '[48;5;10m'
        BACKGROUND.BRIGHTYELLOW = ESCAPE.CODE : '[48;5;11m'
        BACKGROUND.BRIGHTBLUE = ESCAPE.CODE : '[48;5;12m'
        BACKGROUND.BRIGHTMAGENTA = ESCAPE.CODE : '[48;5;13m'
        BACKGROUND.BRIGHTCYAN = ESCAPE.CODE : '[48;5;14m'
        BACKGROUND.BRIGHTWHITE = ESCAPE.CODE : '[48;5;15m'
*
* OVERWRITE FOR WINTEGRATE - TODO
*
        BLACK = ESCAPE.CODE : '[30m'
        RED = ESCAPE.CODE : '[31m'
        GREEN = ESCAPE.CODE : '[32m'
        YELLOW = ESCAPE.CODE : '[33m'
        BLUE = ESCAPE.CODE : '[34m'
        MAGENTA = ESCAPE.CODE : '[35m'
        CYAN = ESCAPE.CODE : '[36m'
        WHITE = ESCAPE.CODE : '[37m'
*
        BRIGHTBLACK = ESCAPE.CODE : '[30;1m'
        BRIGHTRED = ESCAPE.CODE : '[31;1m'
        BRIGHTGREEN = ESCAPE.CODE : '[32;1m'
        BRIGHTYELLOW = ESCAPE.CODE : '[33;1m'
        BRIGHTBLUE = ESCAPE.CODE : '[34;1m'
        BRIGHTMAGENTA = ESCAPE.CODE : '[35;1m'
        BRIGHTCYAN = ESCAPE.CODE : '[36;1m'
        BRIGHTWHITE = ESCAPE.CODE : '[37;1m'
*
        BACKGROUND.BLACK = ESCAPE.CODE : '[40m'
        BACKGROUND.RED = ESCAPE.CODE : '[41m'
        BACKGROUND.GREEN = ESCAPE.CODE : '[42m'
        BACKGROUND.YELLOW = ESCAPE.CODE : '[43m'
        BACKGROUND.BLUE = ESCAPE.CODE : '[44m'
        BACKGROUND.MAGENTA = ESCAPE.CODE : '[45m'
        BACKGROUND.CYAN = ESCAPE.CODE : '[46m'
        BACKGROUND.WHITE = ESCAPE.CODE : '[47m'
*
        BACKGROUND.BRIGHTBLACK = ESCAPE.CODE : '[40;1m'
        BACKGROUND.BRIGHTRED = ESCAPE.CODE : '[41;1m'
        BACKGROUND.BRIGHTGREEN = ESCAPE.CODE : '[42;1m'
        BACKGROUND.BRIGHTYELLOW = ESCAPE.CODE : '[43;1m'
        BACKGROUND.BRIGHTBLUE = ESCAPE.CODE : '[44;1m'
        BACKGROUND.BRIGHTMAGENTA = ESCAPE.CODE : '[45;1m'
        BACKGROUND.BRIGHTCYAN = ESCAPE.CODE : '[46;1m'
        BACKGROUND.BRIGHTWHITE = ESCAPE.CODE : '[47;1m'
    END
*
    EQU NSH.COLORS.ATTRIBUTE TO 1
    EQU NSH.COMMAND.WORDS.ATTRIBUTE TO 2
    EQU NSH.COMMANDS.ATTRIBUTE TO 3
*
    NSH.COLORS = ''
*
    EQU PROMPT.COLOR TO 1
    EQU FOREGROUND.COLOR TO 2
    EQU INPUT.COLOR TO 3
    EQU ERROR.COLOR TO 4
    EQU USER.COLOR TO 5
    EQU PORT.COLOR TO 6
    EQU AT.COLOR TO 7
    EQU ACCOUNT.COLOR TO 8
    EQU SUGGESTION.COLOR TO 9
    EQU BACKGROUND.COLOR TO 10
*
* DARK MODE
*
    NSH.COLORS<PROMPT.COLOR> = BRIGHTCYAN
    NSH.COLORS<FOREGROUND.COLOR> = BRIGHTGREEN
    NSH.COLORS<INPUT.COLOR> = BRIGHTCYAN
    NSH.COLORS<ERROR.COLOR> = BRIGHTRED
*
    NSH.COLORS<USER.COLOR> = BRIGHTYELLOW
    NSH.COLORS<PORT.COLOR> = BRIGHTBLUE
    NSH.COLORS<AT.COLOR> = GREEN
    NSH.COLORS<ACCOUNT.COLOR> = BRIGHTMAGENTA
    NSH.COLORS<SUGGESTION.COLOR> = BRIGHTBLACK
*
    NSH.COLORS<BACKGROUND.COLOR> = BACKGROUND.BLACK
*
    IF NSH.PROFILE # ''  AND NSH.PROFILE<1> # '' THEN
        FOR I = 1 TO DCOUNT(NSH.PROFILE<1>,@VM)
            NSH.COLOR = NSH.PROFILE<1,I>
            IF NSH.COLOR # '' THEN
                NSH.COLORS<I> = ESCAPE.CODE : NSH.COLOR
            END
        NEXT I
    END
*
    USER.COMMAND.WORDS = NSH.PROFILE<NSH.COMMAND.WORDS.ATTRIBUTE>
    USER.COMMANDS = NSH.PROFILE<NSH.COMMANDS.ATTRIBUTE>
*
* VALID VERBS
*
        OPEN '',VOC TO VOC.FILE ELSE
            PRINT 'Unable to open file: ' : VOC:
        END
        SELECT VOC.FILE
        READLIST VALID.VERBS ELSE VALID.VERBS = ''
*
        VALID.VERBS<-1> = 'CLEAR'
        VALID.VERBS<-1> = 'CLS'
        VALID.VERBS<-1> = 'DATECONV'
        VALID.VERBS<-1> = 'EXIT'
        VALID.VERBS<-1> = 'HISTORY'
        VALID.VERBS<-1> = 'MAN'
        VALID.VERBS<-1> = 'NSHUP'
        VALID.VERBS<-1> = 'PRINT'
        VALID.VERBS<-1> = 'Q'
        VALID.VERBS<-1> = 'SEARCH'
        VALID.VERBS<-1> = 'TCL'
        VALID.VERBS<-1> = 'TIMECONV'
        VALID.VERBS<-1> = 'VERSION'
*
*
    SEARCH.COMMAND = ''
    USER.INPUT = TRUE
    TRUE.HISTORY.STACK.POINTER = 0
*
    SERIES.VERBS = ''
    SERIES.VERBS<1,-1> = 'SELECT'
    SERIES.VERBS<1,-1> = 'SSELECT'
    SERIES.VERBS<1,-1> = 'GET-LIST'
    SERIES.VERBS<1,-1> = 'GET.LIST'
    SERIES.VERBS<1,-1> = 'SEARCH'
*
    SERIES = ''
*
    COMMAND = ''
    POSSIBLE.COMMAND = ''
    CURSOR.POSITION = -1
*
    TAB.PRESSED = FALSE
*
    IPADDR = ''
        COMMAND = "hostname -I | cut -d' ' -f1"
            EXECUTE 'SH -c "' : COMMAND : '"' CAPTURING IPADDR
        IPADDR = IPADDR<1>
    IP.X.POS = 132 - LEN(IPADDR) - 1
    IP.Y.POS = 66 - 1
*
    COMMAND = ''
*
    PRINT.SHELL.PROMPT = TRUE
*
    LINUX.COMMAND.MODE = FALSE
*
    PRINT NSH.COLORS<BACKGROUND.COLOR> :
    PRINT NSH.COLORS<FOREGROUND.COLOR> :
    PRINT 'Welcome to NovaShell ' : VERSION : '!'
    PRINT 'NSH: Your term is set to ' : TERMINAL.TYPE : '.'
*
* PRIMARY EXECUTATION LOOP
*
    LOOP WHILE TRUE DO
        IF PRINT.SHELL.PROMPT THEN
            USER.PROMPT = NSH.COLORS<USER.COLOR> : USER.NAME
            PORT.PROMPT = NSH.COLORS<PORT.COLOR> : PORT.NUMBER
            AT.PROMPT = NSH.COLORS<AT.COLOR> : '@'
            COLON.PROMPT = NSH.COLORS<AT.COLOR> : ':'
            ACCOUNT.PROMPT = NSH.COLORS<ACCOUNT.COLOR> : ACCOUNT.NAME
*
            SHELL.PREFIX = USER.PROMPT : COLON.PROMPT : PORT.PROMPT : AT.PROMPT : ACCOUNT.PROMPT
            SHELL.DEFAULT.PROMPT = SHELL.PREFIX : NSH.COLORS<PROMPT.COLOR> : '> ' : NSH.COLORS<INPUT.COLOR>
            SERIES.PROMPT = SHELL.PREFIX : NSH.COLORS<PROMPT.COLOR> : '>> ' : NSH.COLORS<INPUT.COLOR>
*
            RAW.PREFIX = USER.NAME : ':' : PORT.NUMBER : '@' : ACCOUNT.NAME
            RAW.DEFAULT.PROMPT = RAW.PREFIX : '> '
            RAW.SERIES.PROMPT = RAW.PREFIX : '>> '
*
            IF SERIES = '' THEN
                SHELL.PROMPT = SHELL.DEFAULT.PROMPT
                RAW.SHELL.PROMPT = RAW.DEFAULT.PROMPT
            END ELSE
                SHELL.PROMPT = SERIES.PROMPT
                RAW.SHELL.PROMPT = RAW.SERIES.PROMPT
            END
*
            IF SHOW.IP.FLAG THEN
                PRINT @(IP.X.POS,IP.Y.POS) : IPADDR
            END
*
            PRINT BOTTOM :
            PRINT SHELL.PROMPT :
*
            CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
        END
*
        ESCAPE.SEQUENCE = ''
*
* SECONDARY INPUT LOOP
*
        LOOP WHILE TRUE DO
            AT.BEGINNING = FALSE
*
* CHARACTER ENTRY
*
                CHR = KEYIN()
*
* PROCESS CHARACTER
*
            ASCII.CODE = SEQ(CHR)
*
            BEGIN CASE
                CASE ASCII.CODE = SEQ(KEY.CARRIAGE.RETURN)
                    PRINT NSH.COLORS<BACKGROUND.COLOR> :
                    PRINT NSH.COLORS<FOREGROUND.COLOR> :
                    LINUX.COMMAND.MODE = FALSE
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT)
                    TRUE.HISTORY.STACK.POINTER = 0 ;
                    SEARCH.COMMAND = ''
                    USER.INPUT = TRUE
                    EXIT
*
                CASE ASCII.CODE = SEQ(KEY.TAB)
                    TAB.PRESSED = TRUE
                    EXIT
*
                CASE ASCII.CODE = SEQ(KEY.EXCLAIMATION.MARK)
                    LINUX.COMMAND.MODE = TRUE
                        PRINT CHR :
                    COMMAND = COMMAND : CHR
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    CONTINUE
*
                CASE ASCII.CODE = SEQ(KEY.CTRL.A)
                    PRINT BOTTOM :
                    PRINT SHELL.PROMPT :
                    PRINT CLEAR.REST.OF.SCREEN :
                    PRINT.SHELL.PROMPT = FALSE
                    TRUE.HISTORY.STACK.POINTER = 0 ;
                    COMMAND = ''
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    CONTINUE
*
                CASE ASCII.CODE = SEQ(KEY.CTRL.F)
                    IF POSSIBLE.COMMAND # '' THEN
                        COMMAND = POSSIBLE.COMMAND
                        POSSIBLE.COMMAND = ''
*
                        PRINT BOTTOM :
                        PRINT SHELL.PROMPT :
                        PRINT COMMAND :
                        PRINT CLEAR.REST.OF.SCREEN :
*
                        PRINT.SHELL.PROMPT = FALSE
                        TRUE.HISTORY.STACK.POINTER = 0 ;
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    END
*
                    CONTINUE
*
                CASE ASCII.CODE = SEQ(KEY.BACKSPACE) OR ASCII.CODE = SEQ(KEY.DELETE)
                    COMMAND.LENGTH = LEN(COMMAND)
*
                    TRUE.HISTORY.STACK.POINTER = 0 ;
                    SEARCH.COMMAND = ''
                    USER.INPUT = TRUE
*
                    IF COMMAND.LENGTH = 0 THEN
                        AT.BEGINNING = TRUE
                        
                    END ELSE IF COMMAND.LENGTH > 0 THEN
*
                        CURSOR.IN.COMMAND = CURSOR.POSITION - LEN(RAW.SHELL.PROMPT)
*
                        IF CURSOR.IN.COMMAND <= 0 THEN
                            CONTINUE
                        END
*
                        PRINT CHR :
*
                        CURSOR.POSITION = CURSOR.POSITION - 1
*
                        IF CURSOR.IN.COMMAND = LEN(COMMAND) THEN
                            COMMAND = COMMAND[1,LEN(COMMAND) - 1]
                                VERB = FIELD(COMMAND,' ',1)
                                LOCATE(VERB,VALID.VERBS;ANY.POS) THEN
                                    PRINT BOTTOM :
                                    PRINT SHELL.PROMPT :
                                    PRINT NSH.COLORS<INPUT.COLOR> : COMMAND : CLEAR.REST.OF.SCREEN :
                                END ELSE
                                    PRINT BOTTOM :
                                    PRINT SHELL.PROMPT :
                                    PRINT NSH.COLORS<ERROR.COLOR> : COMMAND : CLEAR.REST.OF.SCREEN :
                                END
*
                        END ELSE
*
* SPECIAL DELETE FOR VIEWPOINT
*
                            IF TERMINAL.TYPE = 'viewpoint' OR TERMINAL.TYPE = 'xterm-256color' THEN
                                COMMAND = COMMAND[1,CURSOR.IN.COMMAND-1] : COMMAND[CURSOR.IN.COMMAND+1,9999]
                                PRINT BOTTOM :
                                PRINT SHELL.PROMPT :
                                PRINT COMMAND : CLEAR.REST.OF.SCREEN :
                                    PRINT @(-70, CURSOR.POSITION) :
*
                            END ELSE
                                COMMAND = COMMAND[1,CURSOR.IN.COMMAND-1] : COMMAND[CURSOR.IN.COMMAND+1,9999]
                                    PRINT @(-22) :
                            END
                        END
                    END
*
                    CONTINUE
*
                CASE ASCII.CODE > 0 AND ASCII.CODE < 27
                    ESCAPE.SEQUENCE = ASCII.CODE
                    EXIT
*
                CASE ASCII.CODE = SEQ(KEY.ESCAPE)
                        CHR = KEYIN()
                    ESCAPE.SEQUENCE = CHR
*
                    IF CHR = 'O' THEN
                            CHR = KEYIN()
                        ESCAPE.SEQUENCE = ESCAPE.SEQUENCE : CHR
                    END ELSE IF CHR = '[' THEN
                        LOOP
                                CHR = KEYIN()
                            ESCAPE.SEQUENCE = ESCAPE.SEQUENCE : CHR
                        UNTIL NOT(NUM(CHR)) DO REPEAT
                    END
*
                    EXIT
*
                CASE ASCII.CODE >= SEQ('a') AND ASCII.CODE <= SEQ('z')
                    IF NOT(LINUX.COMMAND.MODE) THEN
                        CHR = OCONV(CHR,'MCU')
                    END
                        PRINT CHR :
*
                CASE ASCII.CODE >= SEQ('A') AND ASCII.CODE <= SEQ('Z')
                    IF NOT(LINUX.COMMAND.MODE) THEN
                        CHR = OCONV(CHR,'MCL')
                    END
                        PRINT CHR :
*
                CASE TRUE
                        PRINT CHR :
            END CASE
*
            IF NOT(AT.BEGINNING) THEN
                CURSOR.POSITION.IN.COMMAND = CURSOR.POSITION - LEN(RAW.SHELL.PROMPT)
*
                IF CURSOR.POSITION.IN.COMMAND = LEN(COMMAND) THEN
                    COMMAND = COMMAND : CHR
                    CURSOR.POSITION = CURSOR.POSITION + 1
*
                    IF TERMINAL.TYPE = 'xterm' OR TERMINAL.TYPE = 'xterm-256color' THEN
                        VERB = FIELD(COMMAND,' ',1)
                        POSSIBLE.COMMAND = ''
*
                        STACK.POINTER = 0
                        HISTORY.LENGTH = DCOUNT(COMMAND.STACK<HISTORY>, @VM)
                        SEARCH.LIMIT = 1000
*
                        IF STACK.POINTER < HISTORY.LENGTH THEN
                            STACK.POINTER = STACK.POINTER + 1
                            IF COMMAND # '' THEN
                                SEARCH.COMMAND = COMMAND
                            END
                            IF SEARCH.COMMAND # '' THEN
                                PREVIOUS.COMMAND = COMMAND
                                LOOP
                                    STACK.COMMAND = COMMAND.STACK<HISTORY, STACK.POINTER>
                                UNTIL (STACK.POINTER >= HISTORY.LENGTH OR INDEX(STACK.COMMAND,SEARCH.COMMAND,1) = 1) OR STACK.POINTER > SEARCH.LIMIT DO
                                    STACK.POINTER = STACK.POINTER + 1
                                REPEAT
                            END
                            POSSIBLE.COMMAND = COMMAND.STACK<HISTORY, STACK.POINTER>
                        END
*
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
                        LOCATE(VERB,VALID.VERBS;ANY.POS) THEN
                            VALID.VERB = TRUE
                        END ELSE
                            IF COMMAND[1,1] = '.' THEN
                                VALID.VERB = TRUE
                            END ELSE
                                VALID.VERB = FALSE
                            END
                        END
*
                        IF VALID.VERB THEN
                            PRINT BOTTOM :
                            PRINT SHELL.PROMPT :
                            PRINT NSH.COLORS<INPUT.COLOR> : COMMAND :
                            PRINT NSH.COLORS<SUGGESTION.COLOR> : POSSIBLE.COMMAND[LEN(COMMAND)+1,9999] :
                            PRINT CLEAR.REST.OF.SCREEN :
                            PRINT @(CURSOR.POSITION) :
                        END ELSE
                            PRINT BOTTOM :
                            PRINT SHELL.PROMPT :
                            PRINT NSH.COLORS<ERROR.COLOR> : COMMAND :
                            PRINT NSH.COLORS<SUGGESTION.COLOR> : POSSIBLE.COMMAND[LEN(COMMAND)+1,9999] :
                            PRINT CLEAR.REST.OF.SCREEN :
                            PRINT @(CURSOR.POSITION) :
                        END
                    END
*
                END ELSE
                    COMMAND = COMMAND[1,CURSOR.POSITION.IN.COMMAND] : CHR : COMMAND[CURSOR.POSITION.IN.COMMAND+1,9999]
                    CURSOR.POSITION = CURSOR.POSITION + 1
                END
            END
*
        REPEAT
*
        PRINT.SHELL.PROMPT = TRUE
*
        COMMAND.STACK.LENGTH = DCOUNT(COMMAND.STACK<HISTORY>, @VM)
        TRUE.HISTORY.LENGTH = DCOUNT(COMMAND.STACK<TRUE.HISTORY>, @VM)
*
* ARROW KEY MANIPULATION
*
        IF ESCAPE.SEQUENCE # '' THEN
            BEGIN CASE
                CASE ESCAPE.SEQUENCE = UP.ARROW
                    IF TRUE.HISTORY.STACK.POINTER < TRUE.HISTORY.LENGTH THEN
                        TRUE.HISTORY.STACK.POINTER = TRUE.HISTORY.STACK.POINTER + 1
                        IF COMMAND # '' AND USER.INPUT = TRUE THEN
                            SEARCH.COMMAND = COMMAND
                        END
                        IF SEARCH.COMMAND # '' THEN
                            PREVIOUS.COMMAND = COMMAND
                            LOOP
                                COMMAND = COMMAND.STACK<TRUE.HISTORY, TRUE.HISTORY.STACK.POINTER>
                            UNTIL (TRUE.HISTORY.STACK.POINTER >= TRUE.HISTORY.LENGTH OR INDEX(COMMAND,SEARCH.COMMAND,1) # 0) AND PREVIOUS.COMMAND # COMMAND DO
                                TRUE.HISTORY.STACK.POINTER = TRUE.HISTORY.STACK.POINTER + 1
                            REPEAT
                        END
                    END
*
                    COMMAND = COMMAND.STACK<TRUE.HISTORY, TRUE.HISTORY.STACK.POINTER>
                    USER.INPUT = FALSE
*
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
                    PRINT BOTTOM :
                    PRINT SHELL.PROMPT :
                    PRINT COMMAND : CLEAR.REST.OF.SCREEN :
*
                    PRINT.SHELL.PROMPT = FALSE
*
                    CONTINUE
*
                CASE ESCAPE.SEQUENCE = DOWN.ARROW
                    IF TRUE.HISTORY.STACK.POINTER > 1 THEN
                        TRUE.HISTORY.STACK.POINTER = TRUE.HISTORY.STACK.POINTER - 1
                        IF COMMAND # '' AND USER.INPUT = TRUE THEN
                            SEARCH.COMMAND = COMMAND
                        END
                        IF SEARCH.COMMAND # '' THEN
                            PREVIOUS.COMMAND = COMMAND
                            LOOP
                                COMMAND = COMMAND.STACK<TRUE.HISTORY, TRUE.HISTORY.STACK.POINTER>
                            UNTIL (TRUE.HISTORY.STACK.POINTER <= 0 OR INDEX(COMMAND,SEARCH.COMMAND,1) # 0) AND PREVIOUS.COMMAND # COMMAND DO
                                TRUE.HISTORY.STACK.POINTER = TRUE.HISTORY.STACK.POINTER - 1
                            REPEAT
                        END
                    END
*
                    IF TRUE.HISTORY.STACK.POINTER <= 0 THEN
                        TRUE.HISTORY.STACK.POINTER = 1
                    END
*
                    COMMAND = COMMAND.STACK<TRUE.HISTORY, TRUE.HISTORY.STACK.POINTER>
                    USER.INPUT = FALSE
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
                    PRINT BOTTOM :
                    PRINT SHELL.PROMPT :
                    PRINT COMMAND : CLEAR.REST.OF.SCREEN :
*
                    PRINT.SHELL.PROMPT = FALSE
*
                    CONTINUE
*
                CASE ESCAPE.SEQUENCE = LEFT.ARROW
                    IF CURSOR.POSITION > LEN(RAW.SHELL.PROMPT) THEN
                        CURSOR.POSITION = CURSOR.POSITION - 1
                        PRINT @(CURSOR.POSITION, 66) :
                            PRINT @(-20) :
                    END
*
                    PRINT.SHELL.PROMPT = FALSE
                    CONTINUE
*
                CASE ESCAPE.SEQUENCE = RIGHT.ARROW
                    IF CURSOR.POSITION < (LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)) THEN
                        CURSOR.POSITION = CURSOR.POSITION + 1
                        PRINT @(CURSOR.POSITION, 66) :
                            PRINT @(-20) :
                    END ELSE
                        IF POSSIBLE.COMMAND # '' THEN
                            COMMAND = POSSIBLE.COMMAND
                            POSSIBLE.COMMAND = ''
*
                            PRINT BOTTOM :
                            PRINT SHELL.PROMPT :
                            PRINT COMMAND :
                            PRINT CLEAR.REST.OF.SCREEN :
*
                            PRINT.SHELL.PROMPT = FALSE
                            TRUE.HISTORY.STACK.POINTER = 0 ;
                            CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                        END
*
                        CONTINUE
*
                    END
*
                    PRINT.SHELL.PROMPT = FALSE
                    CONTINUE
*
                CASE TERMINAL.TYPE = 'wy50' AND (ESCAPE.SEQUENCE = 'i' OR ESCAPE.SEQUENCE = 'I')
                    TAB.PRESSED = TRUE
*
                CASE TRUE
                    PRINT
                    PRINT 'NSH: Escape Sequence: ' : ESCAPE.SEQUENCE : ' not implemented.' :
            END CASE
        END
*
* TAB MANIPULATION
*
        IF TAB.PRESSED THEN
            TAB.PRESSED = FALSE
            NUMBER.OF.ARGUMENTS = DCOUNT(TRIM(COMMAND), ' ')
*
            VERB = FIELD(COMMAND,' ',1)
*
            PRINT NSH.COLORS<BACKGROUND.COLOR> :
            PRINT NSH.COLORS<FOREGROUND.COLOR> :
*
            BEGIN CASE
                CASE LOGTO.OPENED AND VERB = 'LOGTO'
                    VERB = TRIM(FIELD(COMMAND, ' ', 1))
                    WORD = FIELD(COMMAND, ' ', 2)
                    LENGTH.UP.TO.WORD = COL1()
                    CURRENT.COMMAND = COMMAND[1, LENGTH.UP.TO.WORD]
*
                        STATEMENT = 'SSELECT ' : LOGTO.FILENAME : ' = "': WORD : ']"'
*
                    EXECUTE STATEMENT CAPTURING RESULTS
*
                    RECORDS.SELECTED = FIELD(RESULTS<2>, ' ', 1)
*
                    IF RECORDS.SELECTED = 1 THEN
                        READNEXT ITEM.ID ELSE ITEM.ID = ''
*
                        PRINT
                        PRINT BOTTOM :
                        PRINT SHELL.PROMPT :
                        PRINT VERB : ' ' : ITEM.ID : CLEAR.REST.OF.SCREEN :
*
                        COMMAND = VERB : ' ' : ITEM.ID
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
*
                    END ELSE IF RECORDS.SELECTED = 0 THEN
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
*
                    END ELSE
                        PRINT
                        FIRST.WORD = ''
                        LAST.WORD = ''
                        LOOP
                            READNEXT ITEM.ID ELSE ITEM.ID = ''
                        UNTIL ITEM.ID = '' DO
                            PRINT ITEM.ID
                            IF FIRST.WORD = '' THEN FIRST.WORD = ITEM.ID
                            LAST.WORD = ITEM.ID
                        REPEAT
*
                        COMPLETED.WORD = ''
                        FOR I = 1 TO LEN(FIRST.WORD)
                            IF FIRST.WORD[I,1] = LAST.WORD[I,1] THEN
                                COMPLETED.WORD = COMPLETED.WORD : FIRST.WORD[I,1]
                            END ELSE EXIT
                        NEXT I
*
                        COMMAND = CURRENT.COMMAND : COMPLETED.WORD
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
                        PRINT BOTTOM :
                        PRINT SHELL.PROMPT :
                        PRINT COMMAND : CLEAR.REST.OF.SCREEN :
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
                    END
*
                CASE NEW.ACC.OPENED AND NUMBER.OF.ARGUMENTS = 1
                    STATEMENT = 'SSELECT NEWACC = "': TRIM(COMMAND) : ']"'
                    EXECUTE STATEMENT CAPTURING RESULTS
*
                    RECORDS.SELECTED = FIELD(RESULTS<2>, ' ', 1)
*
                    IF RECORDS.SELECTED = 1 THEN
                        READNEXT ITEM.ID ELSE ITEM.ID = ''
                        READV ITEM.DESCRIPTION FROM NEWACC.FILE, ITEM.ID, 1 ELSE ITEM.DESCRIPTION = ''
*
                        PRINT
                        PRINT BOTTOM :
                        PRINT SHELL.PROMPT :
                        PRINT ITEM.ID : CLEAR.REST.OF.SCREEN :
*
                        COMMAND = ITEM.ID
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
*
                    END ELSE IF RECORDS.SELECTED = 0 THEN
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
*
                    END ELSE
                        PRINT
                        FIRST.WORD = ''
                        LAST.WORD = ''
                        LOOP
                            READNEXT ITEM.ID ELSE ITEM.ID = ''
                        UNTIL ITEM.ID = '' DO
                            READV ITEM.DESCRIPTION FROM NEWACC.FILE, ITEM.ID, 1 ELSE ITEM.DESCRIPTION = ''
                            PRINT ITEM.ID 'L#25' : ITEM.DESCRIPTION
                            IF FIRST.WORD = '' THEN FIRST.WORD = ITEM.ID
                            LAST.WORD = ITEM.ID
                        REPEAT
*
                        COMPLETED.WORD = ''
                        FOR I = 1 TO LEN(FIRST.WORD)
                            IF FIRST.WORD[I,1] = LAST.WORD[I,1] THEN
                                COMPLETED.WORD = COMPLETED.WORD : FIRST.WORD[I,1]
                            END ELSE EXIT
                        NEXT I
*
                        COMMAND = COMPLETED.WORD
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
                        PRINT BOTTOM :
                        PRINT SHELL.PROMPT :
                        PRINT COMMAND : CLEAR.REST.OF.SCREEN :
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
                    END
*
                CASE VERB # 'MAN' AND NUMBER.OF.ARGUMENTS = 2
                    VERB = TRIM(FIELD(COMMAND, ' ', 1))
                    WORD = FIELD(COMMAND, ' ', 2)
                    LENGTH.UP.TO.WORD = COL1()
                    CURRENT.COMMAND = COMMAND[1, LENGTH.UP.TO.WORD]
*
                        STATEMENT = 'SSELECT MD = "': WORD : ']" WITH F1 = "F]""Q]"'
*
                    EXECUTE STATEMENT CAPTURING RESULTS
*
                    RECORDS.SELECTED = FIELD(RESULTS<2>, ' ', 1)
*
                    IF RECORDS.SELECTED = 1 THEN
                        READNEXT ITEM.ID ELSE ITEM.ID = ''
*
                        PRINT
                        PRINT BOTTOM :
                        PRINT SHELL.PROMPT :
                        PRINT VERB : ' ' : ITEM.ID : CLEAR.REST.OF.SCREEN :
*
                        COMMAND = VERB : ' ' : ITEM.ID
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
*
                    END ELSE IF RECORDS.SELECTED = 0 THEN
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
*
                    END ELSE
                        PRINT
                        FIRST.WORD = ''
                        LAST.WORD = ''
                        LOOP
                            READNEXT ITEM.ID ELSE ITEM.ID = ''
                        UNTIL ITEM.ID = '' DO
                            PRINT ITEM.ID
                            IF FIRST.WORD = '' THEN FIRST.WORD = ITEM.ID
                            LAST.WORD = ITEM.ID
                        REPEAT
*
                        COMPLETED.WORD = ''
                        FOR I = 1 TO LEN(FIRST.WORD)
                            IF FIRST.WORD[I,1] = LAST.WORD[I,1] THEN
                                COMPLETED.WORD = COMPLETED.WORD : FIRST.WORD[I,1]
                            END ELSE EXIT
                        NEXT I
*
                        COMMAND = CURRENT.COMMAND : COMPLETED.WORD
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
                        PRINT BOTTOM :
                        PRINT SHELL.PROMPT :
                        PRINT COMMAND : CLEAR.REST.OF.SCREEN :
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
                    END
*
                CASE VERB = 'MAN' OR NUMBER.OF.ARGUMENTS > 2
                    VERB = TRIM(FIELD(COMMAND, ' ', 1))
*
                    IF VERB = 'MAN' THEN
                        HELP.FILE.NAME = TRIM(FIELD(COMMAND, ' ', 2))
                        IF HELP.FILE.NAME = "BASIC" THEN
                            FILE.LOOKUP = 'BASIC.HELP'
                        END ELSE
                            FILE.LOOKUP = 'SYS.HELP'
                        END
                    END ELSE
                        FILE.LOOKUP = TRIM(FIELD(COMMAND, ' ', 2))
                    END
*
                    LAST.ELEMENT = DCOUNT(COMMAND,' ')
                    WORD = FIELD(COMMAND, ' ', LAST.ELEMENT)
                    LENGTH.UP.TO.WORD = COL1()
                    CURRENT.COMMAND = COMMAND[1, LENGTH.UP.TO.WORD]
*
                    IF FILE.LOOKUP = 'BASIC.HELP' AND NOT(BASIC.HELP.OPENED) THEN
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
                    END
*
                    IF FILE.LOOKUP = 'SYS.HELP' AND NOT(SYS.HELP.OPENED) THEN
                        PRINT.SHELL.PROMPT = FALSE
                        CONTINUE
                    END
*
                    STATEMENT = 'SSELECT ' : FILE.LOOKUP : ' = "': WORD : ']"'
                    EXECUTE STATEMENT CAPTURING RESULTS
*
                    RECORDS.SELECTED = FIELD(RESULTS<2>, ' ', 1)
*
* DICTIONARY LOOK UP IF WE FOUND NOTHING IN FILE
*
                    BEGIN CASE
                        CASE RECORDS.SELECTED = 0
                            STATEMENT = 'SSELECT DICT ' : FILE.LOOKUP : ' = "': WORD : ']"'
                            EXECUTE STATEMENT CAPTURING RESULTS
*
                            RECORDS.SELECTED = FIELD(RESULTS<2>, ' ', 1)
*
                            IF RECORDS.SELECTED = 1 THEN
                                READNEXT ITEM.ID ELSE ITEM.ID = ''
*
                                PRINT
                                PRINT BOTTOM :
                                PRINT SHELL.PROMPT :
                                PRINT CURRENT.COMMAND : ITEM.ID : CLEAR.REST.OF.SCREEN :
*
                                COMMAND = CURRENT.COMMAND : ITEM.ID
                                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                                PRINT.SHELL.PROMPT = FALSE
                                CONTINUE
*
                            END ELSE IF RECORDS.SELECTED = 0 THEN
                                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                                PRINT.SHELL.PROMPT = FALSE
                                CONTINUE
*
                            END ELSE
                                PRINT
*
                                FIRST.WORD = ''
                                LAST.WORD = ''
                                LOOP
                                    READNEXT ITEM.ID ELSE ITEM.ID = ''
                                UNTIL ITEM.ID = '' DO
                                    PRINT 'DICT: ' : ITEM.ID
                                    IF FIRST.WORD = '' THEN FIRST.WORD = ITEM.ID
                                    LAST.WORD = ITEM.ID
                                REPEAT
*
                                COMPLETED.WORD = ''
                                FOR I = 1 TO LEN(FIRST.WORD)
                                    IF FIRST.WORD[I,1] = LAST.WORD[I,1] THEN
                                        COMPLETED.WORD = COMPLETED.WORD : FIRST.WORD[I,1]
                                    END ELSE EXIT
                                NEXT I
*
                                COMMAND = CURRENT.COMMAND : COMPLETED.WORD
                                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
                                PRINT BOTTOM :
                                PRINT SHELL.PROMPT :
                                PRINT COMMAND : CLEAR.REST.OF.SCREEN :
*
                                PRINT.SHELL.PROMPT = FALSE
                                CONTINUE
                            END
*
                        CASE TRUE
                            IF RECORDS.SELECTED = 1 THEN
                                READNEXT ITEM.ID ELSE ITEM.ID = ''
*
                                PRINT
                                PRINT BOTTOM :
                                PRINT SHELL.PROMPT :
                                PRINT CURRENT.COMMAND : ITEM.ID : CLEAR.REST.OF.SCREEN :
*
                                IF VERB = 'MAN' OR VERB = 'RUN' OR VERB = 'FORMAT' OR FILE.LOOKUP = 'KP' OR VERB = 'EVA' THEN
                                    COMMAND = CURRENT.COMMAND : ITEM.ID
                                END ELSE
                                    COMMAND = CURRENT.COMMAND : '"' : ITEM.ID : '"'
                                END
*
                                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                                PRINT.SHELL.PROMPT = FALSE
                                CONTINUE
*
                            END ELSE IF RECORDS.SELECTED = 0 THEN
                                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                                PRINT.SHELL.PROMPT = FALSE
                                CONTINUE
*
                            END ELSE
                                PRINT
                                FIRST.WORD = ''
                                LAST.WORD = ''
                                LOOP
                                    READNEXT ITEM.ID ELSE ITEM.ID = ''
                                UNTIL ITEM.ID = '' DO
                                    PRINT 'ID: ' : ITEM.ID
                                    IF FIRST.WORD = '' THEN FIRST.WORD = ITEM.ID
                                    LAST.WORD = ITEM.ID
                                REPEAT
*
                                COMPLETED.WORD = ''
                                FOR I = 1 TO LEN(FIRST.WORD)
                                    IF FIRST.WORD[I,1] = LAST.WORD[I,1] THEN
                                        COMPLETED.WORD = COMPLETED.WORD : FIRST.WORD[I,1]
                                    END ELSE EXIT
                                NEXT I
*
                                COMMAND = CURRENT.COMMAND : COMPLETED.WORD
                                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
                                PRINT BOTTOM :
                                PRINT SHELL.PROMPT :
                                PRINT COMMAND : CLEAR.REST.OF.SCREEN :
                                PRINT.SHELL.PROMPT = FALSE
                                CONTINUE
                            END
*
                    END CASE
                CASE TRUE
                    PRINT.SHELL.PROMPT = FALSE
                    CONTINUE
            END CASE
        END
*
        IF COMMAND = '' THEN
            PRINT
            CONTINUE
        END
*
* ADD COMMAND TO TRUE HISTORY
*
        COMMAND.STACK<TRUE.HISTORY> = INSERT(COMMAND.STACK<TRUE.HISTORY>, 1, 1;COMMAND)
        IF NSH.HISTORY.OPENED THEN
            WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
        END
*
        ADD.TO.STACK = TRUE
*
* COMMAND STACK MANIPULATION
*
        IF COMMAND[1,1] = '.' THEN
            COMMAND.NUMBER = COMMAND[3, LEN(COMMAND)]
            PROCEED.STACK.OPERATION = FALSE
*
            IF COMMAND[2,1] = 'A' OR COMMAND[2,1] = 'C' OR COMMAND[2,1] = 'U' THEN
                PROCEED.STACK.OPERATION = TRUE
*
* NUMBER AFTER COMMAND STACK MANIPULATOR
*
            END ELSE
                CONVERT ',' TO @AM IN COMMAND.NUMBER
                COMMAND.NUMBERS = COMMAND.NUMBER
                COMMAND.NUMBER = COMMAND.NUMBER<1>
*
                IF COMMAND.NUMBER = '' THEN
                    COMMAND.NUMBER = 1
                    ADD.TO.STACK = FALSE
                    COMMAND.NUMBERS = COMMAND.NUMBER
                END
*
                IF NUM(COMMAND.NUMBER) THEN
                    IF COMMAND.NUMBER <= COMMAND.STACK.LENGTH THEN
                        PROCEED.STACK.OPERATION = TRUE
                    END ELSE IF COMMAND[2,1] # 'L' THEN
                        PRINT
                        PRINT 'NSH: Error - Command stack is: ' : COMMAND.STACK.LENGTH
                    END
                END
            END
*
            BEGIN CASE
                CASE PROCEED.STACK.OPERATION = FALSE
                    COMMAND = ''
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
                CASE COMMAND[2,1] = 'L'
                    PRINT
                    COMMAND = ''
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    MAX = 20
                    IF COMMAND.STACK.LENGTH <= MAX THEN
                        MAX = COMMAND.STACK.LENGTH
                    END
                    FOR I = MAX TO 1 STEP -1
                        IF I < 10 THEN
                            PRINT '0' : I : ' ' : COMMAND.STACK<HISTORY,I>
                        END ELSE
                            PRINT I : ' ' : COMMAND.STACK<HISTORY,I>
                        END
                    NEXT I
                    CONTINUE
*
                CASE COMMAND[2,1] = 'X'
                    COMMAND = ''
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    IF PROCEED.STACK.OPERATION THEN
                        NUMBER.OF.COMMANDS = DCOUNT(COMMAND.NUMBERS,@AM)
                        FOR I = 1 TO NUMBER.OF.COMMANDS
                            COMMAND.NUMBER = COMMAND.NUMBERS<I>
                            IF NUM(COMMAND.NUMBER) AND COMMAND.NUMBER <= COMMAND.STACK.LENGTH THEN
                                COMMAND<-1> = COMMAND.STACK<HISTORY,COMMAND.NUMBER>
                            END ELSE
                                EXIT
                            END
                        NEXT I
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    END
*
                CASE COMMAND[2,1] = 'D'
                    COMMAND = ''
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    IF PROCEED.STACK.OPERATION THEN
                        PRINT
                        COMMAND.STACK<HISTORY> = DELETE(COMMAND.STACK,1,COMMAND.NUMBER)
                        IF NSH.HISTORY.OPENED THEN
                            WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
                        END
                        PRINT 'NSH: Deleted #' : COMMAND.NUMBER : ' from stack.' :
                    END
*
                CASE COMMAND[2,1] = 'R'
                    COMMAND = ''
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    IF PROCEED.STACK.OPERATION THEN
                        COMMAND = COMMAND.STACK<HISTORY,COMMAND.NUMBER>
                        COMMAND.STACK<HISTORY> = DELETE(COMMAND.STACK,1,COMMAND.NUMBER)
                        COMMAND.STACK<HISTORY> = INSERT(COMMAND.STACK<1>, 1, 1;COMMAND)
                        PRINT
                        IF COMMAND.NUMBER < 10 THEN
                            PRINT '0' : COMMAND.NUMBER : ' ' : COMMAND :
                        END ELSE
                            PRINT COMMAND.NUMBER : ' ' : COMMAND :
                        END
                        IF NSH.HISTORY.OPENED THEN
                            WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
                        END
                        COMMAND = ''
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    END
*
                CASE COMMAND[2,1] = 'A'
                    IF PROCEED.STACK.OPERATION THEN
                        APPEND = COMMAND[3, LEN(COMMAND)]
                        COMMAND.STACK<HISTORY,1> = COMMAND.STACK<HISTORY,1> : APPEND
                        PRINT
                        IF COMMAND.NUMBER < 10 THEN
                            PRINT '0' : COMMAND.NUMBER : ' ' : COMMAND.STACK<HISTORY,1> :
                        END ELSE
                            PRINT COMMAND.NUMBER : ' ' : COMMAND.STACK<HISTORY,1> :
                        END
                        COMMAND = ''
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    END
*
                CASE COMMAND[2,1] = 'U'
                    IF PROCEED.STACK.OPERATION THEN
                        COMMAND.STACK<HISTORY,1> = OCONV(COMMAND.STACK<HISTORY,1>, 'MCU')
                        PRINT
                        IF COMMAND.NUMBER < 10 THEN
                            PRINT '0' : COMMAND.NUMBER : ' ' : COMMAND.STACK<HISTORY,1> :
                        END ELSE
                            PRINT COMMAND.NUMBER : ' ' : COMMAND.STACK<HISTORY,1> :
                        END
                        
                        COMMAND = ''
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    END
*
                CASE COMMAND[2,1] = 'C'
                    IF PROCEED.STACK.OPERATION THEN
                        DELIMITER = '/'
                        NUMBER.OF.DELIMITERS = COUNT(COMMAND, DELIMITER)
*
                        PROCEED = TRUE
*
* CHECK MULTIPLE DELIMITER TYPES
*
                        IF NUMBER.OF.DELIMITERS < 2 OR NUMBER.OF.DELIMITERS > 3 THEN
                            DELIMITER = '!'
                            NUMBER.OF.DELIMITERS = COUNT(COMMAND, DELIMITER)
                            IF NUMBER.OF.DELIMITERS < 2 OR NUMBER.OF.DELIMITERS > 3 THEN
                                PRINT
                                PRINT 'NSH: There needs to be exactly 2 delimiters.' :
                                PROCEED = FALSE
                            END
                        END
*
                        IF PROCEED THEN
                            CHANGE.STACK.POINTER = 1
*
                            NUM1 = FIELD(COMMAND,DELIMITER,1)
*
                            IF LEN(NUM1) = 2 THEN
                                CHANGE.STACK.POINTER = 1
                            END ELSE
                                NUM1 = NUM1[3,99]
                                IF NUM(NUM1) THEN
                                    CHANGE.STACK.POINTER = NUM1
                                END ELSE
                                    CHANGE.STACK.POINTER = 1
                                END
                            END
*
                            IF CHANGE.STACK.POINTER > COMMAND.STACK.LENGTH THEN
                                PRINT
                                PRINT 'NSH: Command does not exist.' :
                                PROCEED = FALSE
                            END
*
                            IF PROCEED THEN
                                STRING1 = FIELD(COMMAND,DELIMITER,2)
                                STRING2 = FIELD(COMMAND,DELIMITER,3)
*
                                IF NUMBER.OF.DELIMITERS = 2 THEN
                                    HOW.MANY = 1
                                END ELSE
                                    HOW.MANY = FIELD(COMMAND,'/',4)
                                    IF HOW.MANY = 'G' THEN
                                        HOW.MANY = -1
                                    END
                                    IF NOT(NUM(HOW.MANY)) THEN
                                        PRINT
                                        PRINT 'NSH: Number of replaces should be a number.' :
                                        PROCEED = FALSE
                                    END
                                END
*
                                IF PROCEED THEN
                                    COMMAND = EREPLACE(COMMAND.STACK<HISTORY,CHANGE.STACK.POINTER>,STRING1,STRING2,HOW.MANY)
                                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
                                    PRINT
                                    IF CHANGE.STACK.POINTER < 10 THEN
                                        PRINT '0' : CHANGE.STACK.POINTER : ' ' : COMMAND :
                                    END ELSE
                                        PRINT CHANGE.STACK.POINTER : ' ' : COMMAND :
                                    END
*
                                    COMMAND.STACK<HISTORY,CHANGE.STACK.POINTER> = COMMAND
                                END
                            END
                        END
                        COMMAND = ''
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    END
*
                CASE TRUE
                    PRINT
                    PRINT 'NSH: Invalid command stack manipulation.' :
                    COMMAND = ''
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
            END CASE
        END
*
* EXECUTE SHELL COMMANDS
*
        IF COMMAND = '!' THEN
                    PRINT
                    EXECUTE 'SH'
                    COMMAND = ''
                    CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
        END ELSE IF COMMAND[1,1] = '!' THEN
            COMMAND = COMMAND[2,LEN(COMMAND)]
                    EXECUTE 'SH -c ' : '"' : COMMAND : '"'
            COMMAND = ''
            CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
        END
*
        PRINT
*
        VERB = FIELD(COMMAND,' ',1)
*
* EXECUTE NSH VERBS
*
        BEGIN CASE
            CASE COMMAND = 'TCL'
                PRINT RESET.COLOR :
                COMMAND = ''
                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                EXIT
*
            CASE COMMAND = 'Q' OR COMMAND = 'EXIT'
                PRINT RESET.COLOR :
                COMMAND = ''
                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                    CHAIN 'Q'
                EXIT
*
            CASE COMMAND = 'CLEAR' OR COMMAND = 'CLS'
                    COMMAND = 'CLR'
                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
            CASE COMMAND[1,3] = 'LS '
                COMMAND = CHANGE(COMMAND, 'LS ', 'LIST ', 1)
                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
            CASE COMMAND = 'HISTORY'
                FOR I = DCOUNT(COMMAND.STACK<TRUE.HISTORY>,@VM) TO 1 STEP -1
                    IF I < 10 THEN
                        PRINT '0' : I : ' ' : COMMAND.STACK<TRUE.HISTORY,I>
                    END ELSE
                        PRINT I : ' ' : COMMAND.STACK<TRUE.HISTORY,I>
                    END
                NEXT I
*
                COMMAND = ''
                CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                CONTINUE
*
* HELP MANIPULATION
*
            CASE VERB = 'MAN'
                COMMAND.STACK<HISTORY> = INSERT(COMMAND.STACK<HISTORY>, 1, 1;COMMAND)
                IF NSH.HISTORY.OPENED THEN
                    WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
                END
*
                ACTION = FIELD(COMMAND,' ',2)
                BASIC.VERB = FIELD(COMMAND,' ',3)
*
* Check If MAN is for BASIC or SYSTEM
*
                BEGIN CASE
                    CASE ACTION = '' AND NOT(SYS.HELP.OPENED)
                        PRINT "NSH: SYS.HELP not available"
                        CONTINUE
*
                    CASE ACTION = 'BASIC' AND NOT(BASIC.HELP.OPENED)
                        PRINT "NSH: BASIC.HELP not available"
                        CONTINUE
*
                    CASE ACTION = ''
                        EXECUTE 'SORT SYS.HELP @ID ID-SUPP'
                        COMMAND = ''
                        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                        CONTINUE
*
                    CASE ACTION = 'BASIC' AND BASIC.VERB # ''
                        READV ACTION.TYPE FROM BASIC.HELP.FILE,BASIC.VERB,2 ELSE ACTION.TYPE = ''
*
                        IF ACTION.TYPE = '' THEN
                            PRINT 'NSH: BASIC keyword not in manual: ' : BASIC.VERB
                            COMMAND = ''
                            CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                            CONTINUE
                        END ELSE
                            PRINT 'NSH: BASIC Help: ' : BASIC.VERB
                            EXECUTE 'LIST BASIC.HELP ' : '"' : BASIC.VERB : '"'
                            COMMAND = ''
                            CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                            CONTINUE
                        END
*
                    CASE TRUE
                        IF NOT(SYS.HELP.OPENED) THEN
                            PRINT "NSH: SYS.HELP not available"
                            CONTINUE
                        END
*
                        READV ACTION.TYPE FROM SYS.HELP.FILE,ACTION,2 ELSE ACTION.TYPE = ''
*
                        IF ACTION.TYPE = '' THEN
                            PRINT 'NSH: System keyword not in manual: ' : ACTION
                            COMMAND = ''
                            CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                            CONTINUE
                        END ELSE
                            PRINT 'NSH: Help: ' : ACTION
                            EXECUTE 'CT SYS.HELP ' : ACTION : ' (S)'
                            COMMAND = ''
                            CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
                            CONTINUE
                        END
*
                END CASE
*
        END CASE
*
        IF ADD.TO.STACK AND COMMAND # '' THEN
            NUMBER.OF.COMMANDS = DCOUNT(COMMAND,@AM)
            FOR I = 1 TO NUMBER.OF.COMMANDS
                COMMAND.STACK<HISTORY> = INSERT(COMMAND.STACK<HISTORY>, 1, 1;COMMAND<I>)
            NEXT I
            IF NSH.HISTORY.OPENED THEN
                WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
            END
        END
*
        NUMBER.OF.COMMANDS = DCOUNT(COMMAND,@AM)
        FOR I = 1 TO NUMBER.OF.COMMANDS
            SERIES<-1> = COMMAND<I>
        NEXT I
*
* EXECUTE CUSTOM COMMANDS
*
        IF VERB = 'LOGTO' THEN
                EXECUTE SERIES
                ACCOUNT.NAME = @WHO
*
        END ELSE IF VERB = 'SEARCH' THEN
                SERIES.LENGTH = DCOUNT(SERIES,@AM)
                IF DCOUNT(COMMAND,' ') >= 3 THEN
                    COMMAND = CHANGE(COMMAND,'"','')
                    SEARCH.FILE = FIELD(COMMAND,' ',2)
                    SEARCH.KEY = TRIM(COMMAND[INDEX(COMMAND,SEARCH.FILE,1)+LEN(SEARCH.FILE)+1,9999])
*
                    PRINT SEARCH.KEY
                    SERIES<SERIES.LENGTH> = 'SEARCH ' : SEARCH.FILE
                    IF SERIES.LENGTH = 2 THEN
                        DATA ''
                    END
                    DATA SEARCH.KEY
                    DATA ''
                END
*
                SERIES<-1> = 'SAVE-LIST ' : USER.NAME : '.' : PORT.NUMBER : '.LIST'
                EXECUTE SERIES CAPTURING RESULTS
*
                PRINT
                MESSAGE = RESULTS<DCOUNT(RESULTS, @AM)-1>
                PRINT MESSAGE
                IF INDEX(MESSAGE,'0 record',1) = 0 THEN
                    SERIES = 'GET-LIST ' : USER.NAME : '.' : PORT.NUMBER : '.LIST'
                END ELSE
                    SERIES = ''
                END
*
*
        END ELSE IF VERB = 'SAVE-LIST' THEN
            EXECUTE SERIES CAPTURING RESULTS
            PRINT
            PRINT RESULTS<4>
*
        END ELSE IF VERB = 'DATECONV' THEN
            LOOP
                PRINT 'Date: ' :
                INPUT DATE
            UNTIL DATE = '' OR OCONV(DATE,"MCU") = 'Q' DO
                IF DATE = 'TODAY' THEN
                    PRINT 'Date: ' : DATE()
                    PRINT OCONV(DATE(),'D')
*
                END ELSE IF LEN(DATE) = 5 THEN
                    PRINT OCONV(DATE,'D')
*
                END ELSE
                    PRINT OCONV(DATE,'DI')
                END
            REPEAT
*
        END ELSE IF VERB = 'TIMECONV' THEN
            LOOP
                PRINT 'Time: ' :
                INPUT TIME
            UNTIL TIME = '' OR OCONV(TIME,"MCU") = 'Q' DO
                IF TIME = 'NOW' THEN
                    PRINT 'Time: ' : TIME()
                    PRINT OCONV(TIME(),'MT')
*
                END ELSE IF LEN(TIME) = 10 THEN
                    PRINT OCONV(TIME+0,'MT')
*
                END ELSE
                    PRINT OCONV(TIME,'T')
                END
            REPEAT
*
        END ELSE IF VERB = 'NSHUP' THEN
            NSHUP.COMMAND = COMMAND[INDEX(COMMAND,' ',1)+1,9999]
*
            SERIES = ''
            COMMAND = ''
*
            BEGIN CASE
                CASE NSHUP.COMMAND = 'SHOW'
                    PRINT 'NSH: Version ' : VERSION
*
                CASE NSHUP.COMMAND = 'CHECK' OR NSHUP.COMMAND = 'UPDATE'
                        NSH.CHECK.COMMAND = 'curl -s ' : NSH.URL : ' | grep "VERSION =" -A2'
                        EXECUTE "SH -c '" : NSH.CHECK.COMMAND : "'" CAPTURING RESULTS
*
                    REMOTE.VERSION = FIELD(RESULTS<1>,"'",2)
*
                    PRINT 'NSH: Current version: ' : VERSION
*
                    IF REMOTE.VERSION > VERSION THEN
                        PRINT 'NSH: Update to ' : REMOTE.VERSION : ' available.'
*
                        IF NSHUP.COMMAND # 'UPDATE' THEN
                            CONTINUE
                        END
*
                        PRINT 'Do you want to update? (y/n) ' :
                        INPUT ANS
*
                        IF ANS # 'Y' THEN
                            CONTINUE
                            PRINT 'NSH: No changes made.'
                        END
*
                        OPEN '',VOC TO VOC.FILE ELSE
                            PRINT 'Unable to open file: ' : VOC :
                            CONTINUE
                        END
*
                        READ NSH.MD.ITEM FROM VOC.FILE,'NSH' ELSE
                            PRINT 'NSH: NSH not found in master dictionary.'
                            CONTINUE
                        END
*
                        PRINT 'Updating...'
*
                            BP = CHANGE(NSH.MD.ITEM<9>,'.O','',1)
*
                            IF INDEX(BP,'/',1) # 0 THEN
                                SERIES = ''
                                PRINT 'NSH: Update from the original NSH location.'
                                PRINT 'NSH: Location: ' : BP
                                PRINT 'NSH: No changes made.'
                                CONTINUE
                            END
*
                            OPEN '',BP TO BP.FILE ELSE
                                PRINT 'Unable to open file: ' : BP :
                                CONTINUE
                            END
*
                            NSH.GET.COMMAND = 'curl -s ' : NSH.URL
                            EXECUTE "SH -c '" : NSH.GET.COMMAND : "'" CAPTURING REMOTE.NSH.FILE
*
                            WRITE REMOTE.NSH.FILE ON BP.FILE,'NSH'
*
                            EXECUTE 'BASIC ' : BP : ' NSH'
*
                            CHAIN 'NSH'
*
                    END ELSE IF REMOTE.VERSION = VERSION THEN
                        PRINT 'NSH: NSH is up to date.'
*
                    END ELSE
                        PRINT 'NSH: Remote version: ' : REMOTE.VERSION
                        PRINT 'NSH: Current version is ahead.'
                    END
*
                CASE NSHUP.COMMAND = 'ENABLE STARTUP'
                    OPEN '',VOC TO VOC.FILE THEN
                        READ POSSIBLE.STARTUP.MATRIX FROM VOC.FILE,USER.NAME THEN
                            IF POSSIBLE.STARTUP.MATRIX = STARTUP.MATRIX THEN
                                PRINT 'NSH: NSH is already enabled on startup.'
                            END ELSE
                                PRINT 'NSH: Did not enable NSH on startup.'
                                PRINT 'NSH: ' : VOC : ' entry for ' : USER.NAME : ' already exists.'
                            END
*
                        END ELSE
                            WRITE STARTUP.MATRIX ON VOC.FILE,USER.NAME
                            PRINT 'NSH: Enabled NSH on startup.'
                        END
                    END
*
                CASE NSHUP.COMMAND = 'DISABLE STARTUP'
                    OPEN '',VOC TO VOC.FILE THEN
                        READU POSSIBLE.STARTUP.MATRIX FROM VOC.FILE,USER.NAME THEN
                            IF POSSIBLE.STARTUP.MATRIX = STARTUP.MATRIX THEN
                                DELETE VOC.FILE,USER.NAME
                                PRINT 'NSH: Disabled NSH from running on startup.'
                            END
                        END ELSE
                            PRINT 'NSH: NSH is not enabled on startup.'
                        END
                    END
*
                CASE TRUE
                    PRINT 'NSH: Invalid NSHUP command.'
            END CASE
*
        END ELSE IF VERB = 'PRINT' THEN
            PRINT.COMMAND = FIELD(COMMAND,' ',2)
*
            IF PRINT.COMMAND[1,5] = 'OCONV' OR PRINT.COMMAND[1,5] = 'ICONV' THEN
                COMMAND = CHANGE(COMMAND,'"','')
*
                START.BRACKET = INDEX(COMMAND,'(',1)
                END.BRACKET = INDEX(COMMAND,')',1)
*
                COMMAND = COMMAND[START.BRACKET+1, END.BRACKET-START.BRACKET-1]
*
                VALUE = FIELD(COMMAND,',',1)
                CONV = FIELD(COMMAND,',',2)
*
                IF PRINT.COMMAND[1,5] = 'OCONV' THEN
                    PRINT OCONV(VALUE,CONV)
                END ELSE IF PRINT.COMMAND[1,5] = 'ICONV' THEN
                    PRINT ICONV(VALUE,CONV)
                END
*
            END ELSE IF PRINT.COMMAND = '@ACCOUNT' THEN
                PRINT @ACCOUNT
            END ELSE IF PRINT.COMMAND = '@WHO' THEN
                PRINT @WHO
            END ELSE IF PRINT.COMMAND = '@LOGNAME' THEN
                PRINT @LOGNAME
            END ELSE IF PRINT.COMMAND = '@USER.NO' THEN
                PRINT @USER.NO
            END ELSE IF PRINT.COMMAND = '@TTY' THEN
                PRINT @TTY
            END ELSE IF PRINT.COMMAND = 'DATE()' THEN
                PRINT DATE()
            END ELSE IF PRINT.COMMAND = 'TIME()' THEN
                PRINT TIME()
            END ELSE
                PRINT 'NSH: Invalid print command.'
            END
*
        END ELSE IF VERB = 'VERSION' THEN
            PRINT 'NSH: Version ' : VERSION
*
        END ELSE
            LOCATE(VERB,USER.COMMAND.WORDS,1;COMMAND.POS) THEN
                SERIES = USER.COMMANDS<1,COMMAND.POS>
                IF SERIES[1,1] = '!' THEN
                    SERIES = 'SH -c ' : '"' : SERIES[2,9999] : '"'
                END
            END
*
            EXECUTE SERIES
        END
*
        LOCATE(VERB,SERIES.VERBS,1;ANY.POS) ELSE
            SERIES = ''
        END
*
        COMMAND = ''
        CURSOR.POSITION = LEN(RAW.SHELL.PROMPT) + LEN(COMMAND)
*
    REPEAT
*
    IF NSH.HISTORY.OPENED THEN
        WRITE COMMAND.STACK ON NSH.HISTORY.FILE, COMMAND.HISTORY.FILE.NAME
    END
*
    PRINT 'NSH: BYE'
*
* END OF PROGRAM.
*
    END

